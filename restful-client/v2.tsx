/* Generated by restful-react */

import React from "react";
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from "restful-react";

type Require<T,R extends keyof T> = T & Required<Pick<T, R>>;
export const SPEC_VERSION = "1.0"; 
/**
 * API error response.
 */
export interface APIErrorResponse {
  /**
   * A list of errors.
   */
  errors: string[];
}

/**
 * Attributes used to create an API Key.
 */
export interface APIKeyCreateAttributes {
  /**
   * Name of the API key.
   */
  name: string;
}

/**
 * Object used to create an API key.
 */
export interface APIKeyCreateData {
  attributes: APIKeyCreateAttributes;
  type: APIKeysType;
}

/**
 * Request used to create an API key.
 */
export interface APIKeyCreateRequest {
  data: APIKeyCreateData;
}

/**
 * Resources related to the API key.
 */
export interface APIKeyRelationships {
  created_by?: RelationshipToUser;
  modified_by?: RelationshipToUser;
}

/**
 * Response for retrieving an API key.
 */
export interface APIKeyResponse {
  data?: FullAPIKey;
  /**
   * Array of objects related to the API key.
   */
  included?: APIKeyResponseIncludedItem[];
}

/**
 * An object related to an API key.
 */
export type APIKeyResponseIncludedItem = User;

/**
 * Attributes used to update an API Key.
 */
export interface APIKeyUpdateAttributes {
  /**
   * Name of the API key.
   */
  name: string;
}

/**
 * Object used to update an API key.
 */
export interface APIKeyUpdateData {
  attributes: APIKeyUpdateAttributes;
  /**
   * ID of the API key.
   */
  id: string;
  type: APIKeysType;
}

/**
 * Request used to update an API key.
 */
export interface APIKeyUpdateRequest {
  data: APIKeyUpdateData;
}

/**
 * Response for a list of API keys.
 */
export interface APIKeysResponse {
  /**
   * Array of API keys.
   */
  data?: PartialAPIKey[];
  /**
   * Array of objects related to the API key.
   */
  included?: APIKeyResponseIncludedItem[];
}

/**
 * Sorting options
 */
export type APIKeysSort = "created_at" | "-created_at" | "last4" | "-last4" | "modified_at" | "-modified_at" | "name" | "-name";

/**
 * API Keys resource type.
 */
export type APIKeysType = "api_keys";

/**
 * Attributes used to create an application Key.
 */
export interface ApplicationKeyCreateAttributes {
  /**
   * Name of the application key.
   */
  name: string;
}

/**
 * Object used to create an application key.
 */
export interface ApplicationKeyCreateData {
  attributes: ApplicationKeyCreateAttributes;
  type: ApplicationKeysType;
}

/**
 * Request used to create an application key.
 */
export interface ApplicationKeyCreateRequest {
  data: ApplicationKeyCreateData;
}

/**
 * Resources related to the application key.
 */
export interface ApplicationKeyRelationships {
  owned_by?: RelationshipToUser;
}

/**
 * Response for retrieving an application key.
 */
export interface ApplicationKeyResponse {
  data?: FullApplicationKey;
  /**
   * Array of objects related to the application key.
   */
  included?: ApplicationKeyResponseIncludedItem[];
}

/**
 * An object related to an application key.
 */
export type ApplicationKeyResponseIncludedItem = User | Role;

/**
 * Attributes used to update an application Key.
 */
export interface ApplicationKeyUpdateAttributes {
  /**
   * Name of the application key.
   */
  name: string;
}

/**
 * Object used to update an application key.
 */
export interface ApplicationKeyUpdateData {
  attributes: ApplicationKeyUpdateAttributes;
  /**
   * ID of the application key.
   */
  id: string;
  type: ApplicationKeysType;
}

/**
 * Request used to update an application key.
 */
export interface ApplicationKeyUpdateRequest {
  data: ApplicationKeyUpdateData;
}

/**
 * Sorting options
 */
export type ApplicationKeysSort = "created_at" | "-created_at" | "last4" | "-last4" | "name" | "-name";

/**
 * Application Keys resource type.
 */
export type ApplicationKeysType = "application_keys";

/**
 * HTTP header used to compress the media-type.
 */
export type ContentEncoding = "gzip" | "deflate";

/**
 * Creator of the object.
 */
export interface Creator {
  /**
   * Email of the creator.
   */
  email?: string;
  /**
   * Handle of the creator.
   */
  handle?: string;
  /**
   * Name of the creator.
   */
  name?: string;
}

/**
 * Request containing a list of dashboards to add.
 */
export interface DashboardListAddItemsRequest {
  /**
   * List of dashboards to add the dashboard list.
   */
  dashboards?: DashboardListItemRequest[];
}

/**
 * Response containing a list of added dashboards.
 */
export interface DashboardListAddItemsResponse {
  /**
   * List of dashboards added to the dashboard list.
   */
  added_dashboards_to_list?: DashboardListItemResponse[];
}

/**
 * Request containing a list of dashboards to delete.
 */
export interface DashboardListDeleteItemsRequest {
  /**
   * List of dashboards to delete from the dashboard list.
   */
  dashboards?: DashboardListItemRequest[];
}

/**
 * Response containing a list of deleted dashboards.
 */
export interface DashboardListDeleteItemsResponse {
  /**
   * List of dashboards deleted from the dashboard list.
   */
  deleted_dashboards_from_list?: DashboardListItemResponse[];
}

/**
 * A dashboard within a list.
 */
export interface DashboardListItem {
  author?: Creator;
  /**
   * Date of creation of the dashboard.
   */
  created?: string;
  /**
   * URL to the icon of the dashboard.
   */
  icon?: string;
  /**
   * ID of the dashboard.
   */
  id: string;
  /**
   * Whether or not the dashboard is in the favorites.
   */
  is_favorite?: boolean;
  /**
   * Whether or not the dashboard is read only.
   */
  is_read_only?: boolean;
  /**
   * Whether the dashboard is publicly shared or not.
   */
  is_shared?: boolean;
  /**
   * Date of last edition of the dashboard.
   */
  modified?: string;
  /**
   * Popularity of the dashboard.
   */
  popularity?: number;
  /**
   * Title of the dashboard.
   */
  title?: string;
  type: DashboardType;
  /**
   * URL path to the dashboard.
   */
  url?: string;
}

/**
 * A dashboard within a list.
 */
export interface DashboardListItemRequest {
  /**
   * ID of the dashboard.
   */
  id: string;
  type: DashboardType;
}

/**
 * A dashboard within a list.
 */
export interface DashboardListItemResponse {
  /**
   * ID of the dashboard.
   */
  id: string;
  type: DashboardType;
}

/**
 * Dashboards within a list.
 */
export interface DashboardListItems {
  /**
   * List of dashboards in the dashboard list.
   */
  dashboards: DashboardListItem[];
  /**
   * Number of dashboards in the dashboard list.
   */
  total?: number;
}

/**
 * Request containing the list of dashboards to update to.
 */
export interface DashboardListUpdateItemsRequest {
  /**
   * List of dashboards to update the dashboard list to.
   */
  dashboards?: DashboardListItemRequest[];
}

/**
 * Response containing a list of updated dashboards.
 */
export interface DashboardListUpdateItemsResponse {
  /**
   * List of dashboards in the dashboard list.
   */
  dashboards?: DashboardListItemResponse[];
}

/**
 * The type of the dashboard.
 */
export type DashboardType = "custom_timeboard" | "custom_screenboard" | "integration_screenboard" | "integration_timeboard" | "host_timeboard";

/**
 * Datadog API key.
 */
export interface FullAPIKey {
  attributes?: FullAPIKeyAttributes;
  /**
   * ID of the API key.
   */
  id?: string;
  relationships?: APIKeyRelationships;
  type?: APIKeysType;
}

/**
 * Attributes of a full API key.
 */
export interface FullAPIKeyAttributes {
  /**
   * Creation date of the API key.
   */
  created_at?: string;
  /**
   * The API key.
   */
  key?: string;
  /**
   * The last four characters of the API key.
   */
  last4?: string;
  /**
   * Date the API key was last modified.
   */
  modified_at?: string;
  /**
   * Name of the API key.
   */
  name?: string;
}

/**
 * Datadog application key.
 */
export interface FullApplicationKey {
  attributes?: FullApplicationKeyAttributes;
  /**
   * ID of the application key.
   */
  id?: string;
  relationships?: ApplicationKeyRelationships;
  type?: ApplicationKeysType;
}

/**
 * Attributes of a full application key.
 */
export interface FullApplicationKeyAttributes {
  /**
   * Creation date of the application key.
   */
  created_at?: string;
  /**
   * The application key.
   */
  key?: string;
  /**
   * The last four characters of the application key.
   */
  last4?: string;
  /**
   * Name of the application key.
   */
  name?: string;
}

/**
 * Structured log message.
 */
export type HTTPLog = HTTPLogItem[];

/**
 * List of errors.
 */
export interface HTTPLogError {
  /**
   * Error message.
   */
  detail?: string;
  /**
   * Error code.
   */
  status?: string;
  /**
   * Error title.
   */
  title?: string;
}

/**
 * Invalid query performed.
 */
export interface HTTPLogErrors {
  /**
   * Structured errors.
   */
  errors?: HTTPLogError[];
}

/**
 * Logs that are sent over HTTP.
 */
export interface HTTPLogItem {
  /**
   * The integration name associated with your log: the technology from which the log originated.
   * When it matches an integration name, Datadog automatically installs the corresponding parsers and facets.
   * See [reserved attributes](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes).
   */
  ddsource?: string;
  /**
   * Tags associated with your logs.
   */
  ddtags?: string;
  /**
   * The name of the originating host of the log.
   */
  hostname?: string;
  /**
   * The message [reserved attribute](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes)
   * of your log. By default, Datadog ingests the value of the message attribute as the body of the log entry.
   * That value is then highlighted and displayed in the Logstream, where it is indexed for full text search.
   */
  message?: string;
  /**
   * The name of the application or service generating the log events.
   * It is used to switch from Logs to APM, so make sure you define the same value when you use both products.
   * See [reserved attributes](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes).
   */
  service?: string;
}

/**
 * The incident's attributes for a create request.
 */
export interface IncidentCreateAttributes {
  /**
   * A flag indicating whether the incident caused customer impact.
   */
  customer_impacted: boolean;
  /**
   * A condensed view of the user-defined fields for which to create initial selections.
   */
  fields?: {
  [key: string]: IncidentFieldAttributes;
};
  /**
   * An array of initial timeline cells to be placed at the beginning of the incident timeline.
   */
  initial_cells?: IncidentTimelineCellCreateAttributes[];
  /**
   * Notification handles that will be notified of the incident at creation.
   */
  notification_handles?: IncidentNotificationHandle[];
  /**
   * The title of the incident, which summarizes what happened.
   */
  title: string;
}

/**
 * Incident data for a create request.
 */
export interface IncidentCreateData {
  attributes: IncidentCreateAttributes;
  relationships?: IncidentCreateRelationships;
  type: IncidentType;
}

/**
 * The relationships the incident will have with other resources once created.
 */
export interface IncidentCreateRelationships {
  commander: RelationshipToUser;
}

/**
 * Create request for an incident.
 */
export interface IncidentCreateRequest {
  data: IncidentCreateData;
}

/**
 * Dynamic fields for which selections can be made, with field names as keys.
 */
export type IncidentFieldAttributes = Require<IncidentFieldAttributesSingleValue | IncidentFieldAttributesMultipleValue, "type">;

/**
 * A field with potentially multiple values selected.
 */
export interface IncidentFieldAttributesMultipleValue {
  type?: IncidentFieldAttributesValueType;
  /**
   * The multiple values selected for this field.
   */
  value?: string[] | null;
}

/**
 * A field with a single value selected.
 */
export interface IncidentFieldAttributesSingleValue {
  type?: IncidentFieldAttributesSingleValueType;
  /**
   * The single value selected for this field.
   */
  value?: string | null;
}

/**
 * Type of the single value field definitions.
 */
export type IncidentFieldAttributesSingleValueType = "dropdown" | "textbox";

/**
 * Type of the single value field definitions.
 */
export type IncidentFieldAttributesValueType = "multiselect" | "textarray" | "metrictag" | "autocomplete";

/**
 * Integration metadata resource type.
 */
export type IncidentIntegrationMetadataType = "incident_integrations";

/**
 * A notification handle that will be notified at incident creation.
 */
export interface IncidentNotificationHandle {
  /**
   * The name of the notified handle.
   */
  display_name?: string;
  /**
   * The email address used for the notification.
   */
  handle?: string;
}

/**
 * Incident postmortem resource type.
 */
export type IncidentPostmortemType = "incident_postmortems";

/**
 * Object related to an incident.
 */
export type IncidentRelatedObject = "users";

/**
 * Response with an incident.
 */
export interface IncidentResponse {
  data: IncidentResponseData;
  /**
   * Included related resources that the user requested.
   */
  included?: IncidentResponseIncludedItem[];
}

/**
 * The incident's attributes from a response.
 */
export interface IncidentResponseAttributes {
  /**
   * Timestamp when the incident was created.
   */
  created?: string;
  /**
   * Length of the incident's customer impact in seconds.
   * Equals the difference between `customer_impact_start` and `customer_impact_end`.
   */
  customer_impact_duration?: number;
  /**
   * Timestamp when customers were no longer impacted by the incident.
   */
  customer_impact_end?: string | null;
  /**
   * A summary of the impact customers experienced during the incident.
   */
  customer_impact_scope?: string | null;
  /**
   * Timestamp when customers began being impacted by the incident.
   */
  customer_impact_start?: string | null;
  /**
   * A flag indicating whether the incident caused customer impact.
   */
  customer_impacted?: boolean;
  /**
   * Timestamp when the incident was detected.
   */
  detected?: string | null;
  /**
   * A condensed view of the user-defined fields attached to incidents.
   */
  fields?: {
  [key: string]: IncidentFieldAttributes;
};
  /**
   * Timestamp when the incident was last modified.
   */
  modified?: string;
  /**
   * Notification handles that will be notified of the incident during update.
   */
  notification_handles?: IncidentNotificationHandle[] | null;
  /**
   * The UUID of the postmortem object attached to the incident.
   */
  postmortem_id?: string;
  /**
   * The monotonically increasing integer ID for the incident.
   */
  public_id?: number;
  /**
   * Timestamp when the incident's state was set to resolved.
   */
  resolved?: string | null;
  /**
   * The amount of time in seconds to detect the incident.
   * Equals the difference between `customer_impact_start` and `detected`.
   */
  time_to_detect?: number;
  /**
   * The amount of time in seconds to call incident after detection. Equals the difference of `detected` and `created`.
   */
  time_to_internal_response?: number;
  /**
   * The amount of time in seconds to resolve customer impact after detecting the issue. Equals the difference between `customer_impact_end` and `detected`.
   */
  time_to_repair?: number;
  /**
   * The amount of time in seconds to resolve the incident after it was created. Equals the difference between `created` and `resolved`.
   */
  time_to_resolve?: number;
  /**
   * The title of the incident, which summarizes what happened.
   */
  title: string;
}

/**
 * Incident data from a response.
 */
export interface IncidentResponseData {
  attributes?: IncidentResponseAttributes;
  /**
   * The incident's ID.
   */
  id: string;
  relationships?: IncidentResponseRelationships;
  type: IncidentType;
}

/**
 * An object related to an incident that is included in the response.
 */
export type IncidentResponseIncludedItem = User;

/**
 * The incident's relationships from a response.
 */
export interface IncidentResponseRelationships {
  commander_user?: RelationshipToUser;
  created_by_user?: RelationshipToUser;
  integrations?: RelationshipToIncidentIntegrationMetadatas;
  last_modified_by_user?: RelationshipToUser;
  postmortem?: RelationshipToIncidentPostmortem;
}

/**
 * The incident service's attributes for a create request.
 */
export interface IncidentServiceCreateAttributes {
  /**
   * Name of the incident service.
   */
  name: string;
}

/**
 * Incident Service payload for create requests.
 */
export interface IncidentServiceCreateData {
  attributes?: IncidentServiceCreateAttributes;
  relationships?: IncidentServiceRelationships;
  type: IncidentServiceType;
}

/**
 * Create request with an incident service payload.
 */
export interface IncidentServiceCreateRequest {
  data: IncidentServiceCreateData;
}

/**
 * An object related to an incident service which is present in the included payload.
 */
export type IncidentServiceIncludedItems = User;

/**
 * The incident service's relationships.
 */
export interface IncidentServiceRelationships {
  created_by?: RelationshipToUser;
  last_modified_by?: RelationshipToUser;
}

/**
 * Response with an incident service payload.
 */
export interface IncidentServiceResponse {
  data: IncidentServiceResponseData;
  /**
   * Included objects from relationships.
   */
  included?: IncidentServiceIncludedItems[];
}

/**
 * The incident service's attributes from a response.
 */
export interface IncidentServiceResponseAttributes {
  /**
   * Timestamp of when the incident service was created.
   */
  created?: string;
  /**
   * Timestamp of when the incident service was modified.
   */
  modified?: string;
  /**
   * Name of the incident service.
   */
  name?: string;
}

/**
 * Incident Service data from responses.
 */
export interface IncidentServiceResponseData {
  attributes?: IncidentServiceResponseAttributes;
  /**
   * The incident service's ID.
   */
  id: string;
  relationships?: IncidentServiceRelationships;
  type: IncidentServiceType;
}

/**
 * Incident service resource type.
 */
export type IncidentServiceType = "services";

/**
 * The incident service's attributes for an update request.
 */
export interface IncidentServiceUpdateAttributes {
  /**
   * Name of the incident service.
   */
  name: string;
}

/**
 * Incident Service payload for update requests.
 */
export interface IncidentServiceUpdateData {
  attributes?: IncidentServiceUpdateAttributes;
  /**
   * The incident service's ID.
   */
  id?: string;
  relationships?: IncidentServiceRelationships;
  type: IncidentServiceType;
}

/**
 * Update request with an incident service payload.
 */
export interface IncidentServiceUpdateRequest {
  data: IncidentServiceUpdateData;
}

/**
 * Response with a list of incident service payloads.
 */
export interface IncidentServicesResponse {
  /**
   * An array of incident services.
   */
  data: IncidentServiceResponseData[];
  /**
   * Included related resources which the user requested.
   */
  included?: IncidentServiceIncludedItems[];
  /**
   * The metadata object containing pagination metadata.
   */
  meta?: {
  /**
   * Pagination properties.
   */
  pagination?: {
  /**
   * The index of the first element in the next page of results. Equal to page size added to the current offset.
   */
  next_offset?: number;
  /**
   * The index of the first element in the results.
   */
  offset?: number;
  /**
   * Maximum size of pages to return.
   */
  size?: number;
};
};
}

/**
 * The incident team's attributes for a create request.
 */
export interface IncidentTeamCreateAttributes {
  /**
   * Name of the incident team.
   */
  name: string;
}

/**
 * Incident Team data for a create request.
 */
export interface IncidentTeamCreateData {
  attributes?: IncidentTeamCreateAttributes;
  relationships?: IncidentTeamRelationships;
  type: IncidentTeamType;
}

/**
 * Create request with an incident team payload.
 */
export interface IncidentTeamCreateRequest {
  data: IncidentTeamCreateData;
}

/**
 * An object related to an incident team which is present in the included payload.
 */
export type IncidentTeamIncludedItems = User;

/**
 * The incident team's relationships.
 */
export interface IncidentTeamRelationships {
  created_by?: RelationshipToUser;
  last_modified_by?: RelationshipToUser;
}

/**
 * Response with an incident team payload.
 */
export interface IncidentTeamResponse {
  data: IncidentTeamResponseData;
  /**
   * Included objects from relationships.
   */
  included?: IncidentTeamIncludedItems[];
}

/**
 * The incident team's attributes from a response.
 */
export interface IncidentTeamResponseAttributes {
  /**
   * Timestamp of when the incident team was created.
   */
  created?: string;
  /**
   * Timestamp of when the incident team was modified.
   */
  modified?: string;
  /**
   * Name of the incident team.
   */
  name?: string;
}

/**
 * Incident Team data from a response.
 */
export interface IncidentTeamResponseData {
  attributes?: IncidentTeamResponseAttributes;
  /**
   * The incident team's ID.
   */
  id?: string;
  relationships?: IncidentTeamRelationships;
  type?: IncidentTeamType;
}

/**
 * Incident Team resource type.
 */
export type IncidentTeamType = "teams";

/**
 * The incident team's attributes for an update request.
 */
export interface IncidentTeamUpdateAttributes {
  /**
   * Name of the incident team.
   */
  name: string;
}

/**
 * Incident Team data for an update request.
 */
export interface IncidentTeamUpdateData {
  attributes?: IncidentTeamUpdateAttributes;
  /**
   * The incident team's ID.
   */
  id?: string;
  relationships?: IncidentTeamRelationships;
  type: IncidentTeamType;
}

/**
 * Update request with an incident team payload.
 */
export interface IncidentTeamUpdateRequest {
  data: IncidentTeamUpdateData;
}

/**
 * Response with a list of incident team payloads.
 */
export interface IncidentTeamsResponse {
  /**
   * An array of incident teams.
   */
  data: IncidentTeamResponseData[];
  /**
   * Included related resources which the user requested.
   */
  included?: IncidentTeamIncludedItems[];
  /**
   * The metadata object containing pagination metadata.
   */
  meta?: {
  /**
   * Pagination properties.
   */
  pagination?: {
  /**
   * The index of the first element in the next page of results. Equal to page size added to the current offset.
   */
  next_offset?: number;
  /**
   * The index of the first element in the results.
   */
  offset?: number;
  /**
   * Maximum size of pages to return.
   */
  size?: number;
};
};
}

/**
 * The timeline cell's attributes for a create request.
 */
export type IncidentTimelineCellCreateAttributes = IncidentTimelineCellMarkdownCreateAttributes;

/**
 * Type of the Markdown timeline cell.
 */
export type IncidentTimelineCellMarkdownContentType = "markdown";

/**
 * Timeline cell data for Markdown timeline cells for a create request.
 */
export interface IncidentTimelineCellMarkdownCreateAttributes {
  cell_type: IncidentTimelineCellMarkdownContentType;
  /**
   * The Markdown timeline cell contents.
   */
  content: {
  /**
   * The Markdown content of the cell.
   */
  content?: string;
};
  /**
   * A flag indicating whether the timeline cell is important and should be highlighted.
   */
  important?: boolean;
}

/**
 * Incident resource type.
 */
export type IncidentType = "incidents";

/**
 * The incident's attributes for an update request.
 */
export interface IncidentUpdateAttributes {
  /**
   * Timestamp when customers were no longer impacted by the incident.
   */
  customer_impact_end?: string | null;
  /**
   * A summary of the impact customers experienced during the incident.
   */
  customer_impact_scope?: string;
  /**
   * Timestamp when customers began being impacted by the incident.
   */
  customer_impact_start?: string | null;
  /**
   * A flag indicating whether the incident caused customer impact.
   */
  customer_impacted?: boolean;
  /**
   * Timestamp when the incident was detected.
   */
  detected?: string | null;
  /**
   * A condensed view of the user-defined fields for which to update selections.
   */
  fields?: {
  [key: string]: IncidentFieldAttributes;
};
  /**
   * Notification handles that will be notified of the incident during update.
   */
  notification_handles?: IncidentNotificationHandle[];
  /**
   * Timestamp when the incident's state was set to resolved.
   */
  resolved?: string | null;
  /**
   * The title of the incident, which summarizes what happened.
   */
  title?: string;
}

/**
 * Incident data for an update request.
 */
export interface IncidentUpdateData {
  attributes?: IncidentUpdateAttributes;
  /**
   * The team's ID.
   */
  id: string;
  relationships?: IncidentUpdateRelationships;
  type: IncidentType;
}

/**
 * The incident's relationships for an update request.
 */
export interface IncidentUpdateRelationships {
  commander_user?: RelationshipToUser;
  created_by_user?: RelationshipToUser;
  integrations?: RelationshipToIncidentIntegrationMetadatas;
  last_modified_by_user?: RelationshipToUser;
  postmortem?: RelationshipToIncidentPostmortem;
}

/**
 * Update request for an incident.
 */
export interface IncidentUpdateRequest {
  data: IncidentUpdateData;
}

/**
 * Response with a list of incidents.
 */
export interface IncidentsResponse {
  /**
   * An array of incidents.
   */
  data: IncidentResponseData[];
  /**
   * Included related resources that the user requested.
   */
  included?: IncidentResponseIncludedItem[];
  /**
   * The metadata object containing pagination metadata.
   */
  meta?: {
  /**
   * Pagination properties.
   */
  pagination?: {
  /**
   * The index of the first element in the next page of results. Equal to page size added to the current offset.
   */
  next_offset?: number;
  /**
   * The index of the first element in the results.
   */
  offset?: number;
  /**
   * Maximum size of pages to return.
   */
  size?: number;
};
};
}

/**
 * Response for a list of application keys.
 */
export interface ListApplicationKeysResponse {
  /**
   * Array of application keys.
   */
  data?: PartialApplicationKey[];
  /**
   * Array of objects related to the application key.
   */
  included?: ApplicationKeyResponseIncludedItem[];
}

/**
 * Object description of a log after being processed and stored by Datadog.
 */
export interface Log {
  /**
   * JSON object containing all log attributes and their associated values.
   */
  attributes?: {
  /**
   * JSON object of attributes from your log.
   */
  attributes?: {[key: string]: any};
  /**
   * Name of the machine from where the logs are being sent.
   */
  host?: string;
  /**
   * The message [reserved attribute](https://docs.datadoghq.com/logs/log_collection/#reserved-attributes)
   * of your log. By default, Datadog ingests the value of the message attribute as the body of the log entry.
   * That value is then highlighted and displayed in the Logstream, where it is indexed for full text search.
   */
  message?: string;
  /**
   * The name of the application or service generating the log events.
   * It is used to switch from Logs to APM, so make sure you define the same
   * value when you use both products.
   */
  service?: string;
  /**
   * Status of the message associated with your log.
   */
  status?: string;
  /**
   * Array of tags associated with your log.
   */
  tags?: string[];
  /**
   * Timestamp of your log.
   */
  timestamp?: string;
};
  /**
   * Unique ID of the Log.
   */
  id?: string;
  type?: LogType;
}

/**
 * Type of the event.
 */
export type LogType = "log";

/**
 * A bucket values
 */
export interface LogsAggregateBucket {
  /**
   * The key, value pairs for each group by
   */
  by?: {
  [key: string]: string;
};
  /**
   * A map of the metric name -> value for regular compute or list of values for a timeseries
   */
  computes?: {
  [key: string]: LogsAggregateBucketValue;
};
}

/**
 * A bucket value, can be either a timeseries or a single value
 */
export type LogsAggregateBucketValue = LogsAggregateBucketValueSingleString | LogsAggregateBucketValueSingleNumber | LogsAggregateBucketValueTimeseries;

/**
 * A single number value
 */
export type LogsAggregateBucketValueSingleNumber = number;

/**
 * A single string value
 */
export type LogsAggregateBucketValueSingleString = string;

/**
 * A timeseries array
 */
export type LogsAggregateBucketValueTimeseries = LogsAggregateBucketValueTimeseriesPoint[];

/**
 * A timeseries point
 */
export interface LogsAggregateBucketValueTimeseriesPoint {
  /**
   * The time value for this point
   */
  time?: string;
  /**
   * The value for this point
   */
  value?: number;
}

/**
 * The object sent with the request to retrieve a list of logs from your organization.
 */
export interface LogsAggregateRequest {
  /**
   * The list of metrics or timeseries to compute for the retrieved buckets.
   */
  compute?: LogsCompute[];
  filter?: LogsQueryFilter;
  /**
   * The rules for the group by
   */
  group_by?: LogsGroupBy[];
  options?: LogsQueryOptions;
  /**
   * Paging settings
   */
  page?: {
  /**
   * The returned paging point to use to get the next results
   */
  cursor?: string;
};
}

/**
 * The response object for the logs aggregate API endpoint
 */
export interface LogsAggregateResponse {
  /**
   * The query results
   */
  data?: {
  /**
   * The list of matching buckets, one item per bucket
   */
  buckets?: LogsAggregateBucket[];
};
  meta?: LogsResponseMetadata;
}

/**
 * The status of the response
 */
export type LogsAggregateResponseStatus = "done" | "timeout";

/**
 * A sort rule
 */
export interface LogsAggregateSort {
  aggregation?: LogsAggregationFunction;
  /**
   * The metric to sort by (only used for `type=measure`)
   */
  metric?: string;
  order?: LogsSortOrder;
  type?: LogsAggregateSortType;
}

/**
 * The type of sorting algorithm
 */
export type LogsAggregateSortType = "alphabetical" | "measure";

/**
 * An aggregation function
 */
export type LogsAggregationFunction = "count" | "cardinality" | "pc75" | "pc90" | "pc95" | "pc98" | "pc99" | "sum" | "min" | "max" | "avg";

/**
 * The logs archive.
 */
export interface LogsArchive {
  data?: LogsArchiveDefinition;
}

/**
 * The attributes associated with the archive.
 */
export interface LogsArchiveAttributes {
  destination: LogsArchiveDestination;
  /**
   * To store the tags in the archive, set the value "true".
   * If it is set to "false", the tags will be deleted when the logs are sent to the archive.
   */
  include_tags?: boolean;
  /**
   * The archive name.
   */
  name: string;
  /**
   * The archive query/filter. Logs matching this query are included in the archive.
   */
  query: string;
  /**
   * An array of tags to add to rehydrated logs from an archive.
   */
  rehydration_tags?: string[];
  state?: LogsArchiveState;
}

/**
 * The logs archive.
 */
export interface LogsArchiveCreateRequest {
  data?: LogsArchiveCreateRequestDefinition;
}

/**
 * The attributes associated with the archive.
 */
export interface LogsArchiveCreateRequestAttributes {
  destination: LogsArchiveCreateRequestDestination;
  /**
   * To store the tags in the archive, set the value "true".
   * If it is set to "false", the tags will be deleted when the logs are sent to the archive.
   */
  include_tags?: boolean;
  /**
   * The archive name.
   */
  name: string;
  /**
   * The archive query/filter. Logs matching this query are included in the archive.
   */
  query: string;
  /**
   * An array of tags to add to rehydrated logs from an archive.
   */
  rehydration_tags?: string[];
}

/**
 * The definition of an archive.
 */
export interface LogsArchiveCreateRequestDefinition {
  attributes?: LogsArchiveCreateRequestAttributes;
  /**
   * The type of the resource. The value should always be archives.
   */
  type: string;
}

/**
 * An archive's destination.
 */
export type LogsArchiveCreateRequestDestination = Require<LogsArchiveDestinationAzure | LogsArchiveDestinationGCS | LogsArchiveDestinationS3, "type" | "integration">;

/**
 * The definition of an archive.
 */
export interface LogsArchiveDefinition {
  attributes?: LogsArchiveAttributes;
  /**
   * The archive ID.
   */
  id?: string;
  /**
   * The type of the resource. The value should always be archives.
   */
  type: string;
}

/**
 * An archive's destination.
 */
export type LogsArchiveDestination = Require<LogsArchiveDestinationAzure | LogsArchiveDestinationGCS | LogsArchiveDestinationS3, "type" | "integration"> | null;

/**
 * The Azure archive destination.
 */
export interface LogsArchiveDestinationAzure {
  /**
   * The container where the archive will be stored.
   */
  container: string;
  integration: LogsArchiveIntegrationAzure;
  /**
   * The archive path.
   */
  path?: string;
  /**
   * The region where the archive will be stored.
   */
  region?: string;
  /**
   * The associated storage account.
   */
  storage_account: string;
  type: LogsArchiveDestinationAzureType;
}

/**
 * Type of the Azure archive destination.
 */
export type LogsArchiveDestinationAzureType = "azure";

/**
 * The GCS archive destination.
 */
export interface LogsArchiveDestinationGCS {
  /**
   * The bucket where the archive will be stored.
   */
  bucket: string;
  integration: LogsArchiveIntegrationGCS;
  /**
   * The archive path.
   */
  path?: string;
  type: LogsArchiveDestinationGCSType;
}

/**
 * Type of the GCS archive destination.
 */
export type LogsArchiveDestinationGCSType = "gcs";

/**
 * The S3 archive destination.
 */
export interface LogsArchiveDestinationS3 {
  /**
   * The bucket where the archive will be stored.
   */
  bucket: string;
  integration: LogsArchiveIntegrationS3;
  /**
   * The archive path.
   */
  path?: string;
  type: LogsArchiveDestinationS3Type;
}

/**
 * Type of the S3 archive destination.
 */
export type LogsArchiveDestinationS3Type = "s3";

/**
 * The Azure archive's integration destination.
 */
export interface LogsArchiveIntegrationAzure {
  /**
   * A client ID.
   */
  client_id: string;
  /**
   * A tenant ID.
   */
  tenant_id: string;
}

/**
 * The GCS archive's integration destination.
 */
export interface LogsArchiveIntegrationGCS {
  /**
   * A client email.
   */
  client_email: string;
  /**
   * A project ID.
   */
  project_id: string;
}

/**
 * The S3 Archive's integration destination.
 */
export interface LogsArchiveIntegrationS3 {
  /**
   * The account ID for the integration.
   */
  account_id: string;
  /**
   * The path of the integration.
   */
  role_name: string;
}

/**
 * A ordered list of archive IDs.
 */
export interface LogsArchiveOrder {
  data?: LogsArchiveOrderDefinition;
}

/**
 * The attributes associated with the archive order.
 */
export interface LogsArchiveOrderAttributes {
  /**
   * An ordered array of `<ARCHIVE_ID>` strings, the order of archive IDs in the array
   * define the overall archives order for Datadog.
   */
  archive_ids: string[];
}

/**
 * The definition of an archive order.
 */
export interface LogsArchiveOrderDefinition {
  attributes: LogsArchiveOrderAttributes;
  type: LogsArchiveOrderDefinitionType;
}

/**
 * Type of the archive order definition.
 */
export type LogsArchiveOrderDefinitionType = "archive_order";

/**
 * The state of the archive.
 */
export type LogsArchiveState = "UNKNOWN" | "WORKING" | "FAILING" | "WORKING_AUTH_LEGACY";

/**
 * The available archives.
 */
export interface LogsArchives {
  /**
   * A list of archives.
   */
  data?: LogsArchiveDefinition[];
}

/**
 * A compute rule to compute metrics or timeseries
 */
export interface LogsCompute {
  aggregation: LogsAggregationFunction;
  /**
   * The time buckets' size (only used for type=timeseries)
   * Defaults to a resolution of 150 points
   */
  interval?: string;
  /**
   * The metric to use
   */
  metric?: string;
  type?: LogsComputeType;
}

/**
 * The type of compute
 */
export type LogsComputeType = "timeseries" | "total";

/**
 * A group by rule
 */
export interface LogsGroupBy {
  /**
   * The name of the facet to use (required)
   */
  facet: string;
  /**
   * Used to perform a histogram computation (only for measure facets).
   * Note: At most 100 buckets are allowed, the number of buckets is (max - min)/interval.
   */
  histogram?: {
  /**
   * The bin size of the histogram buckets
   */
  interval: number;
  /**
   * The maximum value for the measure used in the histogram
   * (values greater than this one are filtered out)
   */
  max: number;
  /**
   * The minimum value for the measure used in the histogram
   * (values smaller than this one are filtered out)
   */
  min: number;
};
  /**
   * The maximum buckets to return for this group by
   */
  limit?: number;
  missing?: LogsGroupByMissing;
  sort?: LogsAggregateSort;
  total?: LogsGroupByTotal;
}

/**
 * The value to use for logs that don't have the facet used to group by
 */
export type LogsGroupByMissing = LogsGroupByMissingString | LogsGroupByMissingNumber;

/**
 * The missing value to use if there is a number valued facet.
 */
export type LogsGroupByMissingNumber = number;

/**
 * The missing value to use if there is string valued facet.
 */
export type LogsGroupByMissingString = string;

/**
 * A resulting object to put the given computes in over all the matching records.
 */
export type LogsGroupByTotal = LogsGroupByTotalBoolean | LogsGroupByTotalString | LogsGroupByTotalNumber;

/**
 * If set to true, creates an additional bucket labeled "$facet_total"
 */
export type LogsGroupByTotalBoolean = boolean;

/**
 * A number to use as the key value for the total bucket
 */
export type LogsGroupByTotalNumber = number;

/**
 * A string to use as the key value for the total bucket
 */
export type LogsGroupByTotalString = string;

/**
 * The request for a logs list.
 */
export interface LogsListRequest {
  filter?: LogsQueryFilter;
  options?: LogsQueryOptions;
  /**
   * Paging attributes for listing logs.
   */
  page?: {
  /**
   * List following results with a cursor provided in the previous query.
   */
  cursor?: string;
  /**
   * Maximum number of logs in the response.
   */
  limit?: number;
};
  sort?: LogsSort;
}

/**
 * Response object with all logs matching the request and pagination information.
 */
export interface LogsListResponse {
  /**
   * Array of logs matching the request.
   */
  data?: Log[];
  /**
   * Links attributes.
   */
  links?: {
  /**
   * Link for the next set of results. Note that the request can also be made using the
   * POST endpoint.
   */
  next?: string;
};
  meta?: LogsResponseMetadata;
}

/**
 * The compute rule to compute the log-based metric.
 */
export interface LogsMetricCompute {
  aggregation_type: LogsMetricComputeAggregationType;
  /**
   * The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution").
   */
  path?: string;
}

/**
 * The type of aggregation to use.
 */
export type LogsMetricComputeAggregationType = "count" | "distribution";

/**
 * The object describing the Datadog log-based metric to create.
 */
export interface LogsMetricCreateAttributes {
  compute: LogsMetricCompute;
  filter?: LogsMetricFilter;
  /**
   * The rules for the group by.
   */
  group_by?: LogsMetricGroupBy[];
}

/**
 * The new log-based metric properties.
 */
export interface LogsMetricCreateData {
  attributes: LogsMetricCreateAttributes;
  id: LogsMetricID;
  type: LogsMetricType;
}

/**
 * The new log-based metric body.
 */
export interface LogsMetricCreateRequest {
  data: LogsMetricCreateData;
}

/**
 * The log-based metric filter. Logs matching this filter will be aggregated in this metric.
 */
export interface LogsMetricFilter {
  /**
   * The search query - following the log search syntax.
   */
  query?: string;
}

/**
 * A group by rule.
 */
export interface LogsMetricGroupBy {
  /**
   * The path to the value the log-based metric will be aggregated over.
   */
  path: string;
  /**
   * Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
   */
  tag_name?: string;
}

/**
 * The name of the log-based metric.
 */
export type LogsMetricID = string;

/**
 * The log-based metric object.
 */
export interface LogsMetricResponse {
  data?: LogsMetricResponseData;
}

/**
 * The object describing a Datadog log-based metric.
 */
export interface LogsMetricResponseAttributes {
  compute?: LogsMetricResponseCompute;
  filter?: LogsMetricResponseFilter;
  /**
   * The rules for the group by.
   */
  group_by?: LogsMetricResponseGroupBy[];
}

/**
 * The compute rule to compute the log-based metric.
 */
export interface LogsMetricResponseCompute {
  aggregation_type?: LogsMetricResponseComputeAggregationType;
  /**
   * The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution").
   */
  path?: string;
}

/**
 * The type of aggregation to use.
 */
export type LogsMetricResponseComputeAggregationType = "count" | "distribution";

/**
 * The log-based metric properties.
 */
export interface LogsMetricResponseData {
  attributes?: LogsMetricResponseAttributes;
  id?: LogsMetricID;
  type?: LogsMetricType;
}

/**
 * The log-based metric filter. Logs matching this filter will be aggregated in this metric.
 */
export interface LogsMetricResponseFilter {
  /**
   * The search query - following the log search syntax.
   */
  query?: string;
}

/**
 * A group by rule.
 */
export interface LogsMetricResponseGroupBy {
  /**
   * The path to the value the log-based metric will be aggregated over.
   */
  path?: string;
  /**
   * Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
   */
  tag_name?: string;
}

/**
 * The type of the resource. The value should always be logs_metrics.
 */
export type LogsMetricType = "logs_metrics";

/**
 * The log-based metric properties that will be updated.
 */
export interface LogsMetricUpdateAttributes {
  filter?: LogsMetricFilter;
  /**
   * The rules for the group by.
   */
  group_by?: LogsMetricGroupBy[];
}

/**
 * The new log-based metric properties.
 */
export interface LogsMetricUpdateData {
  attributes: LogsMetricUpdateAttributes;
  type: LogsMetricType;
}

/**
 * The new log-based metric body.
 */
export interface LogsMetricUpdateRequest {
  data: LogsMetricUpdateData;
}

/**
 * All the available log-based metric objects.
 */
export interface LogsMetricsResponse {
  /**
   * A list of log-based metric objects.
   */
  data?: LogsMetricResponseData[];
}

/**
 * The search and filter query settings
 */
export interface LogsQueryFilter {
  /**
   * The minimum time for the requested logs, supports date math and regular timestamps
   */
  from?: string;
  /**
   * For customers with multiple indexes, the indexes to search. Defaults to ['*'] which means all indexes.
   */
  indexes?: string[];
  /**
   * The search query - following the log search syntax.
   */
  query?: string;
  /**
   * The maximum time for the requested logs, supports date math and regular timestamps
   */
  to?: string;
}

/**
 * Global query options that are used during the query.
 * Note: You should only supply timezone or time offset but not both otherwise the query will fail.
 */
export interface LogsQueryOptions {
  /**
   * The time offset (in seconds) to apply to the query.
   */
  timeOffset?: number;
  /**
   * The timezone can be specified both as an offset, for example: "UTC+03:00".
   */
  timezone?: string;
}

/**
 * The metadata associated with a request
 */
export interface LogsResponseMetadata {
  /**
   * The time elapsed in milliseconds
   */
  elapsed?: number;
  /**
   * Paging attributes.
   */
  page?: {
  /**
   * The cursor to use to get the next results, if any. To make the next request, use the same.
   * parameters with the addition of the `page[cursor]`.
   */
  after?: string;
};
  /**
   * The identifier of the request
   */
  request_id?: string;
  status?: LogsAggregateResponseStatus;
  /**
   * A list of warnings (non fatal errors) encountered, partial results might be returned if
   * warnings are present in the response.
   */
  warnings?: LogsWarning[];
}

/**
 * Sort parameters when querying logs.
 */
export type LogsSort = "timestamp" | "-timestamp";

/**
 * The order to use, ascending or descending
 */
export type LogsSortOrder = "asc" | "desc";

/**
 * A warning message indicating something that went wrong with the query
 */
export interface LogsWarning {
  /**
   * A unique code for this type of warning
   */
  code?: string;
  /**
   * A detailed explanation of this specific warning
   */
  detail?: string;
  /**
   * A short human-readable summary of the warning
   */
  title?: string;
}

/**
 * Object for a single metric tag configuration.
 */
export interface Metric {
  id?: MetricName;
  type?: MetricType;
}

/**
 * Object for a single metric's indexed tags.
 */
export interface MetricAllTags {
  attributes?: MetricAllTagsAttributes;
  id?: MetricName;
  type?: MetricType;
}

/**
 * Object containing the definition of a metric's tags.
 */
export interface MetricAllTagsAttributes {
  /**
   * List of indexed tag value pairs.
   */
  tags?: string[];
}

/**
 * Response object that includes a single metric's indexed tags.
 */
export interface MetricAllTagsResponse {
  data?: MetricAllTags;
}

/**
 * A time and space aggregation combination for use in query.
 */
export interface MetricCustomAggregation {
  space: MetricCustomSpaceAggregation;
  time: MetricCustomTimeAggregation;
}

/**
 * A list of queryable aggregation combinations for a count, rate, or gauge metric.
 * By default, count and rate metrics require the (time: sum, space: sum) aggregation and
 * Gauge metrics require the (time: avg, space: avg) aggregation.
 * Additional time & space combinations are also available:
 * 
 * - time: avg, space: avg
 * - time: avg, space: max
 * - time: avg, space: min
 * - time: avg, space: sum
 * - time: count, space: sum
 * - time: max, space: max
 * - time: min, space: min
 * - time: sum, space: avg
 * - time: sum, space: sum
 * 
 * Can only be applied to metrics that have a `metric_type` of `count`, `rate`, or `gauge`.
 */
export type MetricCustomAggregations = MetricCustomAggregation[];

/**
 * A space aggregation for use in query.
 */
export type MetricCustomSpaceAggregation = "avg" | "max" | "min" | "sum";

/**
 * A time aggregation for use in query.
 */
export type MetricCustomTimeAggregation = "avg" | "count" | "max" | "min" | "sum";

/**
 * Object for a single metric's distinct volume.
 */
export interface MetricDistinctVolume {
  attributes?: MetricDistinctVolumeAttributes;
  id?: MetricName;
  type?: MetricDistinctVolumeType;
}

/**
 * Object containing the definition of a metric's distinct volume.
 */
export interface MetricDistinctVolumeAttributes {
  /**
   * Distinct volume for the given metric.
   */
  distinct_volume?: number;
}

/**
 * The metric distinct volume type.
 */
export type MetricDistinctVolumeType = "distinct_metric_volumes";

/**
 * Object for a single metric's ingested and indexed volume.
 */
export interface MetricIngestedIndexedVolume {
  attributes?: MetricIngestedIndexedVolumeAttributes;
  id?: MetricName;
  type?: MetricIngestedIndexedVolumeType;
}

/**
 * Object containing the definition of a metric's ingested and indexed volume.
 */
export interface MetricIngestedIndexedVolumeAttributes {
  /**
   * Indexed volume for the given metric.
   */
  indexed_volume?: number;
  /**
   * Ingested volume for the given metric.
   */
  ingested_volume?: number;
}

/**
 * The metric ingested and indexed volume type.
 */
export type MetricIngestedIndexedVolumeType = "metric_volumes";

/**
 * The metric name for this resource.
 */
export type MetricName = string;

/**
 * Object for a single metric tag configuration.
 */
export interface MetricTagConfiguration {
  attributes?: MetricTagConfigurationAttributes;
  id?: MetricName;
  type?: MetricTagConfigurationType;
}

/**
 * Object containing the definition of a metric tag configuration attributes.
 */
export interface MetricTagConfigurationAttributes {
  aggregations?: MetricCustomAggregations;
  /**
   * Timestamp when the tag configuration was created.
   */
  created_at?: string;
  /**
   * Toggle to turn on/off percentile aggregations for distribution metrics.
   * Only present when the `metric_type` is `distribution`.
   */
  include_percentiles?: boolean;
  metric_type?: MetricTagConfigurationMetricTypes;
  /**
   * Timestamp when the tag configuration was last modified.
   */
  modified_at?: string;
  /**
   * List of tag keys on which to group.
   */
  tags?: string[];
}

/**
 * Object containing the definition of a metric tag configuration to be created.
 */
export interface MetricTagConfigurationCreateAttributes {
  aggregations?: MetricCustomAggregations;
  /**
   * Toggle to include/exclude percentiles for a distribution metric.
   * Defaults to false. Can only be applied to metrics that have a `metric_type` of `distribution`.
   */
  include_percentiles?: boolean;
  metric_type: MetricTagConfigurationMetricTypes;
  /**
   * A list of tag keys that will be queryable for your metric.
   */
  tags: string[];
}

/**
 * Object for a single metric to be configure tags on.
 */
export interface MetricTagConfigurationCreateData {
  attributes?: MetricTagConfigurationCreateAttributes;
  id: MetricName;
  type: MetricTagConfigurationType;
}

/**
 * Request object that includes the metric that you would like to configure tags for.
 */
export interface MetricTagConfigurationCreateRequest {
  data: MetricTagConfigurationCreateData;
}

/**
 * The metric's type.
 */
export type MetricTagConfigurationMetricTypes = "gauge" | "count" | "rate" | "distribution";

/**
 * Response object which includes a single metric's tag configuration.
 */
export interface MetricTagConfigurationResponse {
  data?: MetricTagConfiguration;
}

/**
 * The metric tag configuration resource type.
 */
export type MetricTagConfigurationType = "manage_tags";

/**
 * Object containing the definition of a metric tag configuration to be updated.
 */
export interface MetricTagConfigurationUpdateAttributes {
  aggregations?: MetricCustomAggregations;
  /**
   * Toggle to include/exclude percentiles for a distribution metric.
   * Defaults to false. Can only be applied to metrics that have a `metric_type` of `distribution`.
   */
  include_percentiles?: boolean;
  /**
   * A list of tag keys that will be queryable for your metric.
   */
  tags?: string[];
}

/**
 * Object for a single tag configuration to be edited.
 */
export interface MetricTagConfigurationUpdateData {
  attributes?: MetricTagConfigurationUpdateAttributes;
  id: MetricName;
  type: MetricTagConfigurationType;
}

/**
 * Request object that includes the metric that you would like to edit the tag configuration on.
 */
export interface MetricTagConfigurationUpdateRequest {
  data: MetricTagConfigurationUpdateData;
}

/**
 * The metric resource type.
 */
export type MetricType = "metrics";

/**
 * Possible response objects for a metric's volume.
 */
export type MetricVolumes = MetricDistinctVolume | MetricIngestedIndexedVolume;

/**
 * Response object which includes a single metric's volume.
 */
export interface MetricVolumesResponse {
  data?: MetricVolumes;
}

/**
 * Object for a metrics and metric tag configurations.
 */
export type MetricsAndMetricTagConfigurations = Metric | MetricTagConfiguration;

/**
 * Response object that includes metrics and metric tag configurations.
 */
export interface MetricsAndMetricTagConfigurationsResponse {
  /**
   * Array of metrics and metric tag configurations.
   */
  data?: MetricsAndMetricTagConfigurations[];
}

/**
 * Organization object.
 */
export interface Organization {
  attributes?: OrganizationAttributes;
  /**
   * ID of the organization.
   */
  id?: string;
  type: OrganizationsType;
}

/**
 * Attributes of the organization.
 */
export interface OrganizationAttributes {
  /**
   * Creation time of the organization.
   */
  created_at?: string;
  /**
   * Description of the organization.
   */
  description?: string;
  /**
   * Whether or not the organization is disabled.
   */
  disabled?: boolean;
  /**
   * Time of last organization modification.
   */
  modified_at?: string;
  /**
   * Name of the organization.
   */
  name?: string;
  /**
   * Public ID of the organization.
   */
  public_id?: string;
  /**
   * Sharing type of the organization.
   */
  sharing?: string;
  /**
   * URL of the site that this organization exists at.
   */
  url?: string;
}

/**
 * Organizations resource type.
 */
export type OrganizationsType = "orgs";

/**
 * Pagination object.
 */
export interface Pagination {
  /**
   * Total count.
   */
  total_count?: number;
  /**
   * Total count of elements matched by the filter.
   */
  total_filtered_count?: number;
}

/**
 * Partial Datadog API key.
 */
export interface PartialAPIKey {
  attributes?: PartialAPIKeyAttributes;
  /**
   * ID of the API key.
   */
  id?: string;
  relationships?: APIKeyRelationships;
  type?: APIKeysType;
}

/**
 * Attributes of a partial API key.
 */
export interface PartialAPIKeyAttributes {
  /**
   * Creation date of the API key.
   */
  created_at?: string;
  /**
   * The last four characters of the API key.
   */
  last4?: string;
  /**
   * Date the API key was last modified.
   */
  modified_at?: string;
  /**
   * Name of the API key.
   */
  name?: string;
}

/**
 * Partial Datadog application key.
 */
export interface PartialApplicationKey {
  attributes?: PartialApplicationKeyAttributes;
  /**
   * ID of the application key.
   */
  id?: string;
  relationships?: ApplicationKeyRelationships;
  type?: ApplicationKeysType;
}

/**
 * Attributes of a partial application key.
 */
export interface PartialApplicationKeyAttributes {
  /**
   * Creation date of the application key.
   */
  created_at?: string;
  /**
   * The last four characters of the application key.
   */
  last4?: string;
  /**
   * Name of the application key.
   */
  name?: string;
}

/**
 * Response for retrieving a partial application key.
 */
export interface PartialApplicationKeyResponse {
  data?: PartialApplicationKey;
  /**
   * Array of objects related to the application key.
   */
  included?: ApplicationKeyResponseIncludedItem[];
}

/**
 * Permission object.
 */
export interface Permission {
  attributes?: PermissionAttributes;
  /**
   * ID of the permission.
   */
  id?: string;
  type: PermissionsType;
}

/**
 * Attributes of a permission.
 */
export interface PermissionAttributes {
  /**
   * Creation time of the permission.
   */
  created?: string;
  /**
   * Description of the permission.
   */
  description?: string;
  /**
   * Displayed name for the permission.
   */
  display_name?: string;
  /**
   * Display type.
   */
  display_type?: string;
  /**
   * Name of the permission group.
   */
  group_name?: string;
  /**
   * Name of the permission.
   */
  name?: string;
  /**
   * Whether or not the permission is restricted.
   */
  restricted?: boolean;
}

/**
 * Payload with API-returned permissions.
 */
export interface PermissionsResponse {
  /**
   * Array of permissions.
   */
  data?: Permission[];
}

/**
 * Permissions resource type.
 */
export type PermissionsType = "permissions";

/**
 * Response metadata object.
 */
export interface ProcessSummariesMeta {
  /**
   * Paging attributes.
   */
  page?: {
  /**
   * The cursor used to get the next results, if any. To make the next request, use the same
   * parameters with the addition of the `page[cursor]`.
   */
  after?: string;
  /**
   * Number of results returned.
   */
  size?: number;
};
}

/**
 * List of process summaries.
 */
export interface ProcessSummariesResponse {
  /**
   * Array of process summary objects.
   */
  data?: ProcessSummary[];
  meta?: ProcessSummariesMeta;
}

/**
 * Process summary object.
 */
export interface ProcessSummary {
  attributes?: ProcessSummaryAttributes;
  /**
   * Process ID.
   */
  id?: string;
  type?: ProcessSummaryType;
}

/**
 * Attributes for a process summary.
 */
export interface ProcessSummaryAttributes {
  /**
   * Process command line.
   */
  cmdline?: string;
  /**
   * Host running the process.
   */
  host?: string;
  /**
   * Process ID.
   */
  pid?: number;
  /**
   * Parent process ID.
   */
  ppid?: number;
  /**
   * Time the process was started.
   */
  start?: string;
  /**
   * List of tags associated with the process.
   */
  tags?: string[];
  /**
   * Time the process was seen.
   */
  timestamp?: string;
  /**
   * Process owner.
   */
  user?: string;
}

/**
 * Type of process summary.
 */
export type ProcessSummaryType = "process";

/**
 * Direction of sort.
 */
export type QuerySortOrder = "asc" | "desc";

/**
 * A relationship reference for an integration metadata object.
 */
export interface RelationshipToIncidentIntegrationMetadataData {
  /**
   * A unique identifier that represents the integration metadata.
   */
  id: string;
  type: IncidentIntegrationMetadataType;
}

/**
 * A relationship reference for multiple integration metadata objects.
 */
export interface RelationshipToIncidentIntegrationMetadatas {
  /**
   * The integration metadata relationship array
   */
  data: RelationshipToIncidentIntegrationMetadataData[];
}

/**
 * A relationship reference for postmortems.
 */
export interface RelationshipToIncidentPostmortem {
  data: RelationshipToIncidentPostmortemData;
}

/**
 * The postmortem relationship data.
 */
export interface RelationshipToIncidentPostmortemData {
  /**
   * A unique identifier that represents the postmortem.
   */
  id: string;
  type: IncidentPostmortemType;
}

/**
 * Relationship to an organization.
 */
export interface RelationshipToOrganization {
  data: RelationshipToOrganizationData;
}

/**
 * Relationship to organization object.
 */
export interface RelationshipToOrganizationData {
  /**
   * ID of the organization.
   */
  id: string;
  type: OrganizationsType;
}

/**
 * Relationship to organizations.
 */
export interface RelationshipToOrganizations {
  /**
   * Relationships to organization objects.
   */
  data: RelationshipToOrganizationData[];
}

/**
 * Relationship to a permissions object.
 */
export interface RelationshipToPermission {
  data?: RelationshipToPermissionData;
}

/**
 * Relationship to permission object.
 */
export interface RelationshipToPermissionData {
  /**
   * ID of the permission.
   */
  id?: string;
  type?: PermissionsType;
}

/**
 * Relationship to multiple permissions objects.
 */
export interface RelationshipToPermissions {
  /**
   * Relationships to permission objects.
   */
  data?: RelationshipToPermissionData[];
}

/**
 * Relationship to role.
 */
export interface RelationshipToRole {
  data?: RelationshipToRoleData;
}

/**
 * Relationship to role object.
 */
export interface RelationshipToRoleData {
  /**
   * ID of the role.
   */
  id?: string;
  type?: RolesType;
}

/**
 * Relationship to roles.
 */
export interface RelationshipToRoles {
  /**
   * An array containing type and ID of a role.
   */
  data?: RelationshipToRoleData[];
}

/**
 * Relationship to user.
 */
export interface RelationshipToUser {
  data: RelationshipToUserData;
}

/**
 * Relationship to user object.
 */
export interface RelationshipToUserData {
  /**
   * A unique identifier that represents the user.
   */
  id: string;
  type: UsersType;
}

/**
 * Relationship to users.
 */
export interface RelationshipToUsers {
  /**
   * Relationships to user objects.
   */
  data: RelationshipToUserData[];
}

/**
 * Object describing meta attributes of response.
 */
export interface ResponseMetaAttributes {
  page?: Pagination;
}

/**
 * Role object returned by the API.
 */
export interface Role {
  attributes?: RoleAttributes;
  /**
   * ID of the role.
   */
  id?: string;
  relationships?: RoleResponseRelationships;
  type: RolesType;
}

/**
 * Attributes of the role.
 */
export interface RoleAttributes {
  /**
   * Creation time of the role.
   */
  created_at?: string;
  /**
   * Time of last role modification.
   */
  modified_at?: string;
  /**
   * Name of the role.
   */
  name?: string;
  /**
   * Number of users with that role.
   */
  user_count?: number;
}

/**
 * Attributes of the created role.
 */
export interface RoleCreateAttributes {
  /**
   * Creation time of the role.
   */
  created_at?: string;
  /**
   * Time of last role modification.
   */
  modified_at?: string;
  /**
   * Name of the role.
   */
  name: string;
}

/**
 * Data related to the creation of a role.
 */
export interface RoleCreateData {
  attributes: RoleCreateAttributes;
  relationships?: RoleRelationships;
  type?: RolesType;
}

/**
 * Create a role.
 */
export interface RoleCreateRequest {
  data: RoleCreateData;
}

/**
 * Response containing information about a created role.
 */
export interface RoleCreateResponse {
  /**
   * Role object returned by the API.
   */
  data?: {
  attributes?: RoleCreateAttributes;
  /**
   * ID of the role.
   */
  id?: string;
  relationships?: RoleResponseRelationships;
  type: RolesType;
};
}

/**
 * Relationships of the role object.
 */
export interface RoleRelationships {
  permissions?: RelationshipToPermissions;
  users?: RelationshipToUsers;
}

/**
 * Response containing information about a single role.
 */
export interface RoleResponse {
  data?: Role;
}

/**
 * Relationships of the role object returned by the API.
 */
export interface RoleResponseRelationships {
  permissions?: RelationshipToPermissions;
}

/**
 * Attributes of the role.
 */
export interface RoleUpdateAttributes {
  /**
   * Creation time of the role.
   */
  created_at?: string;
  /**
   * Time of last role modification.
   */
  modified_at?: string;
  /**
   * Name of the role.
   */
  name?: string;
}

/**
 * Data related to the update of a role.
 */
export interface RoleUpdateData {
  attributes: RoleUpdateAttributes;
  /**
   * ID of the role.
   */
  id: string;
  type: RolesType;
}

/**
 * Update a role.
 */
export interface RoleUpdateRequest {
  data: RoleUpdateData;
}

/**
 * Response containing information about an updated role.
 */
export interface RoleUpdateResponse {
  /**
   * Role object returned by the API.
   */
  data?: {
  attributes?: RoleUpdateAttributes;
  /**
   * ID of the role.
   */
  id?: string;
  relationships?: RoleResponseRelationships;
  type: RolesType;
};
}

/**
 * Response containing information about multiple roles.
 */
export interface RolesResponse {
  /**
   * Array of returned roles.
   */
  data?: Role[];
  meta?: ResponseMetaAttributes;
}

/**
 * Sorting options for roles.
 */
export type RolesSort = "name" | "-name" | "modified_at" | "-modified_at" | "user_count" | "-user_count";

/**
 * Roles type.
 */
export type RolesType = "roles";

/**
 * The security filter's properties.
 */
export interface SecurityFilter {
  attributes?: SecurityFilterAttributes;
  id?: SecurityFilterID;
  type?: SecurityFilterType;
}

/**
 * The object describing a security filter.
 */
export interface SecurityFilterAttributes {
  /**
   * The list of exclusion filters applied in this security filter.
   */
  exclusion_filters?: SecurityFilterExclusionFilterResponse[];
  filtered_data_type?: SecurityFilterFilteredDataType;
  /**
   * Whether the security filter is the built-in filter.
   */
  is_builtin?: boolean;
  /**
   * Whether the security filter is enabled.
   */
  is_enabled?: boolean;
  /**
   * The security filter name.
   */
  name?: string;
  /**
   * The security filter query. Logs accepted by this query will be accepted by this filter.
   */
  query?: string;
  /**
   * The version of the security filter.
   */
  version?: number;
}

/**
 * Object containing the attributes of the security filter to be created.
 */
export interface SecurityFilterCreateAttributes {
  /**
   * Exclusion filters to exclude some logs from the security filter.
   */
  exclusion_filters: SecurityFilterExclusionFilter[];
  filtered_data_type: SecurityFilterFilteredDataType;
  /**
   * Whether the security filter is enabled.
   */
  is_enabled: boolean;
  /**
   * The name of the security filter.
   */
  name: string;
  /**
   * The query of the security filter.
   */
  query: string;
}

/**
 * Object for a single security filter.
 */
export interface SecurityFilterCreateData {
  attributes: SecurityFilterCreateAttributes;
  type: SecurityFilterType;
}

/**
 * Request object that includes the security filter that you would like to create.
 */
export interface SecurityFilterCreateRequest {
  data: SecurityFilterCreateData;
}

/**
 * Exclusion filter for the security filter.
 */
export interface SecurityFilterExclusionFilter {
  /**
   * Exclusion filter name.
   */
  name: string;
  /**
   * Exclusion filter query. Logs that match this query are excluded from the security filter.
   */
  query: string;
}

/**
 * A single exclusion filter.
 */
export interface SecurityFilterExclusionFilterResponse {
  /**
   * The exclusion filter name.
   */
  name?: string;
  /**
   * The exclusion filter query.
   */
  query?: string;
}

/**
 * The filtered data type.
 */
export type SecurityFilterFilteredDataType = "logs";

/**
 * The ID of the security filter.
 */
export type SecurityFilterID = string;

/**
 * Optional metadata associated to the response.
 */
export interface SecurityFilterMeta {
  /**
   * A warning message.
   */
  warning?: string;
}

/**
 * Response object which includes a single security filter.
 */
export interface SecurityFilterResponse {
  data?: SecurityFilter;
  meta?: SecurityFilterMeta;
}

/**
 * The type of the resource. The value should always be `security_filters`.
 */
export type SecurityFilterType = "security_filters";

/**
 * The security filters properties to be updated.
 */
export interface SecurityFilterUpdateAttributes {
  /**
   * Exclusion filters to exclude some logs from the security filter.
   */
  exclusion_filters?: SecurityFilterExclusionFilter[];
  filtered_data_type?: SecurityFilterFilteredDataType;
  /**
   * Whether the security filter is enabled.
   */
  is_enabled?: boolean;
  /**
   * The name of the security filter.
   */
  name?: string;
  /**
   * The query of the security filter.
   */
  query?: string;
  /**
   * The version of the security filter to update.
   */
  version?: number;
}

/**
 * The new security filter properties.
 */
export interface SecurityFilterUpdateData {
  attributes: SecurityFilterUpdateAttributes;
  type: SecurityFilterType;
}

/**
 * The new security filter body.
 */
export interface SecurityFilterUpdateRequest {
  data: SecurityFilterUpdateData;
}

/**
 * All the available security filters objects.
 */
export interface SecurityFiltersResponse {
  /**
   * A list of security filters objects.
   */
  data?: SecurityFilter[];
  meta?: SecurityFilterMeta;
}

/**
 * The rule's suppression filter.
 */
export interface SecurityMonitoringFilter {
  action?: SecurityMonitoringFilterAction;
  /**
   * Query for selecting logs to apply the filtering action.
   */
  query?: string;
}

/**
 * The type of filtering action.
 */
export type SecurityMonitoringFilterAction = "require" | "suppress";

/**
 * List of rules.
 */
export interface SecurityMonitoringListRulesResponse {
  /**
   * Array containing the list of rules.
   */
  data?: SecurityMonitoringRuleResponse[];
  meta?: ResponseMetaAttributes;
}

/**
 * Case when signal is generated.
 */
export interface SecurityMonitoringRuleCase {
  /**
   * A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated
   * based on the event counts in the previously defined queries.
   */
  condition?: string;
  /**
   * Name of the case.
   */
  name?: string;
  /**
   * Notification targets for each rule case.
   */
  notifications?: string[];
  status?: SecurityMonitoringRuleSeverity;
}

/**
 * Case when signal is generated.
 */
export interface SecurityMonitoringRuleCaseCreate {
  /**
   * A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated
   * based on the event counts in the previously defined queries.
   */
  condition?: string;
  /**
   * Name of the case.
   */
  name?: string;
  /**
   * Notification targets for each rule case.
   */
  notifications?: string[];
  status: SecurityMonitoringRuleSeverity;
}

/**
 * Create a new rule.
 */
export interface SecurityMonitoringRuleCreatePayload {
  /**
   * Cases for generating signals.
   */
  cases: SecurityMonitoringRuleCaseCreate[];
  /**
   * Additional queries to filter matched events before they are processed.
   */
  filters?: SecurityMonitoringFilter[];
  /**
   * Whether the notifications include the triggering group-by values in their title.
   */
  hasExtendedTitle?: boolean;
  /**
   * Whether the rule is enabled.
   */
  isEnabled: boolean;
  /**
   * Message for generated signals.
   */
  message: string;
  /**
   * The name of the rule.
   */
  name: string;
  options: SecurityMonitoringRuleOptions;
  /**
   * Queries for selecting logs which are part of the rule.
   */
  queries: SecurityMonitoringRuleQueryCreate[];
  /**
   * Tags for generated signals.
   */
  tags?: string[];
  type?: SecurityMonitoringRuleTypeCreate;
}

/**
 * The detection method.
 */
export type SecurityMonitoringRuleDetectionMethod = "threshold" | "new_value" | "anomaly_detection";

/**
 * A time window is specified to match when at least one of the cases matches true. This is a sliding window
 * and evaluates in real time.
 */
export type SecurityMonitoringRuleEvaluationWindow = 0 | 60 | 300 | 600 | 900 | 1800 | 3600 | 7200;

/**
 * Once a signal is generated, the signal will remain open if a case is matched at least once within
 * this keep alive window.
 */
export type SecurityMonitoringRuleKeepAlive = 0 | 60 | 300 | 600 | 900 | 1800 | 3600 | 7200 | 10800 | 21600;

/**
 * A signal will close regardless of the query being matched once the time exceeds the maximum duration.
 * This time is calculated from the first seen timestamp.
 */
export type SecurityMonitoringRuleMaxSignalDuration = 0 | 60 | 300 | 600 | 900 | 1800 | 3600 | 7200 | 10800 | 21600 | 43200 | 86400;

/**
 * Options on new value rules.
 */
export interface SecurityMonitoringRuleNewValueOptions {
  forgetAfter?: SecurityMonitoringRuleNewValueOptionsForgetAfter;
  learningDuration?: SecurityMonitoringRuleNewValueOptionsLearningDuration;
}

/**
 * The duration in days after which a learned value is forgotten.
 */
export type SecurityMonitoringRuleNewValueOptionsForgetAfter = 1 | 2 | 7 | 14 | 21 | 28;

/**
 * The duration in days during which values are learned, and after which signals will be generated for values that
 * weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned.
 */
export type SecurityMonitoringRuleNewValueOptionsLearningDuration = 0 | 1 | 7;

/**
 * Options on rules.
 */
export interface SecurityMonitoringRuleOptions {
  detectionMethod?: SecurityMonitoringRuleDetectionMethod;
  evaluationWindow?: SecurityMonitoringRuleEvaluationWindow;
  keepAlive?: SecurityMonitoringRuleKeepAlive;
  maxSignalDuration?: SecurityMonitoringRuleMaxSignalDuration;
  newValueOptions?: SecurityMonitoringRuleNewValueOptions;
}

/**
 * Query for matching rule.
 */
export interface SecurityMonitoringRuleQuery {
  agentRule?: SecurityMonitoringRuntimeAgentRule;
  aggregation?: SecurityMonitoringRuleQueryAggregation;
  /**
   * Field for which the cardinality is measured. Sent as an array.
   */
  distinctFields?: string[];
  /**
   * Fields to group by.
   */
  groupByFields?: string[];
  /**
   * The target field to aggregate over when using the sum or max
   * aggregations.
   */
  metric?: string;
  /**
   * Name of the query.
   */
  name?: string;
  /**
   * Query to run on logs.
   */
  query?: string;
}

/**
 * The aggregation type.
 */
export type SecurityMonitoringRuleQueryAggregation = "count" | "cardinality" | "sum" | "max" | "new_value";

/**
 * Query for matching rule.
 */
export interface SecurityMonitoringRuleQueryCreate {
  agentRule?: SecurityMonitoringRuntimeAgentRule;
  aggregation?: SecurityMonitoringRuleQueryAggregation;
  /**
   * Field for which the cardinality is measured. Sent as an array.
   */
  distinctFields?: string[];
  /**
   * Fields to group by.
   */
  groupByFields?: string[];
  /**
   * The target field to aggregate over when using the sum or max
   * aggregations.
   */
  metric?: string;
  /**
   * Name of the query.
   */
  name?: string;
  /**
   * Query to run on logs.
   */
  query: string;
}

/**
 * Rule.
 */
export interface SecurityMonitoringRuleResponse {
  /**
   * Cases for generating signals.
   */
  cases?: SecurityMonitoringRuleCase[];
  /**
   * When the rule was created, timestamp in milliseconds.
   */
  createdAt?: number;
  /**
   * User ID of the user who created the rule.
   */
  creationAuthorId?: number;
  /**
   * Additional queries to filter matched events before they are processed.
   */
  filters?: SecurityMonitoringFilter[];
  /**
   * Whether the notifications include the triggering group-by values in their title.
   */
  hasExtendedTitle?: boolean;
  /**
   * The ID of the rule.
   */
  id?: string;
  /**
   * Whether the rule is included by default.
   */
  isDefault?: boolean;
  /**
   * Whether the rule has been deleted.
   */
  isDeleted?: boolean;
  /**
   * Whether the rule is enabled.
   */
  isEnabled?: boolean;
  /**
   * Message for generated signals.
   */
  message?: string;
  /**
   * The name of the rule.
   */
  name?: string;
  options?: SecurityMonitoringRuleOptions;
  /**
   * Queries for selecting logs which are part of the rule.
   */
  queries?: SecurityMonitoringRuleQuery[];
  /**
   * Tags for generated signals.
   */
  tags?: string[];
  type?: SecurityMonitoringRuleTypeRead;
  /**
   * User ID of the user who updated the rule.
   */
  updateAuthorId?: number;
  /**
   * The version of the rule.
   */
  version?: number;
}

/**
 * Severity of the Security Signal.
 */
export type SecurityMonitoringRuleSeverity = "info" | "low" | "medium" | "high" | "critical";

/**
 * The rule type.
 */
export type SecurityMonitoringRuleTypeCreate = "log_detection" | "workload_security";

/**
 * The rule type.
 */
export type SecurityMonitoringRuleTypeRead = "log_detection" | "infrastructure_configuration" | "workload_security" | "cloud_configuration";

/**
 * Update an existing rule.
 */
export interface SecurityMonitoringRuleUpdatePayload {
  /**
   * Cases for generating signals.
   */
  cases?: SecurityMonitoringRuleCase[];
  /**
   * Additional queries to filter matched events before they are processed.
   */
  filters?: SecurityMonitoringFilter[];
  /**
   * Whether the notifications include the triggering group-by values in their title.
   */
  hasExtendedTitle?: boolean;
  /**
   * Whether the rule is enabled.
   */
  isEnabled?: boolean;
  /**
   * Message for generated signals.
   */
  message?: string;
  /**
   * Name of the rule.
   */
  name?: string;
  options?: SecurityMonitoringRuleOptions;
  /**
   * Queries for selecting logs which are part of the rule.
   */
  queries?: SecurityMonitoringRuleQuery[];
  /**
   * Tags for generated signals.
   */
  tags?: string[];
  /**
   * The version of the rule being updated.
   */
  version?: number;
}

/**
 * The Agent rule.
 */
export interface SecurityMonitoringRuntimeAgentRule {
  /**
   * The Agent rule ID. Must be unique within the rule.
   */
  agentRuleId?: string;
  /**
   * A Runtime Security expression determines what activity should be collected by the Datadog Agent.
   * These logical expressions can use predefined operators and attributes. Tags cannot be used in Runtime
   * Security expressions. Instead, allow or deny based on tags under the advanced option.
   */
  expression?: string;
}

/**
 * Object description of a security signal.
 */
export interface SecurityMonitoringSignal {
  /**
   * The object containing all signal attributes and their
   * associated values.
   */
  attributes?: {
  /**
   * A JSON object of attributes in the security signal.
   */
  attributes?: {[key: string]: any};
  /**
   * The message in the security signal defined by the rule that generated the signal.
   */
  message?: string;
  /**
   * An array of tags associated with the security signal.
   */
  tags?: {};
  /**
   * The timestamp of the security signal.
   */
  timestamp?: string;
};
  /**
   * The unique ID of the security signal.
   */
  id?: string;
  type?: SecurityMonitoringSignalType;
}

/**
 * The request for a security signal list.
 */
export interface SecurityMonitoringSignalListRequest {
  /**
   * Search filters for listing security signals.
   */
  filter?: {
  /**
   * The minimum timestamp for requested security signals.
   */
  from?: string;
  /**
   * Search query for listing security signals.
   */
  query?: string;
  /**
   * The maximum timestamp for requested security signals.
   */
  to?: string;
};
  /**
   * The paging attributes for listing security signals.
   */
  page?: {
  /**
   * A list of results using the cursor provided in the previous query.
   */
  cursor?: string;
  /**
   * The maximum number of security signals in the response.
   */
  limit?: number;
};
  sort?: SecurityMonitoringSignalsSort;
}

/**
 * The type of event.
 */
export type SecurityMonitoringSignalType = "signal";

/**
 * The response object with all security signals matching the request
 * and pagination information.
 */
export interface SecurityMonitoringSignalsListResponse {
  /**
   * An array of security signals matching the request.
   */
  data?: SecurityMonitoringSignal[];
  /**
   * Links attributes.
   */
  links?: {
  /**
   * The link for the next set of results. **Note**: The request can also be made using the
   * POST endpoint.
   */
  next?: string;
};
  /**
   * Meta attributes.
   */
  meta?: {
  /**
   * Paging attributes.
   */
  page?: {
  /**
   * The cursor used to get the next results, if any. To make the next request, use the same
   * parameters with the addition of the `page[cursor]`.
   */
  after?: string;
};
};
}

/**
 * The sort parameters used for querying security signals.
 */
export type SecurityMonitoringSignalsSort = "timestamp" | "-timestamp";

/**
 * Attributes of the created user.
 */
export interface ServiceAccountCreateAttributes {
  /**
   * The email of the user.
   */
  email: string;
  /**
   * The name of the user.
   */
  name?: string;
  /**
   * Whether the user is a service account. Must be true.
   */
  service_account: boolean;
  /**
   * The title of the user.
   */
  title?: string;
}

/**
 * Object to create a service account User.
 */
export interface ServiceAccountCreateData {
  attributes: ServiceAccountCreateAttributes;
  relationships?: UserRelationships;
  type: UsersType;
}

/**
 * Create a service account.
 */
export interface ServiceAccountCreateRequest {
  data: ServiceAccountCreateData;
}

/**
 * User object returned by the API.
 */
export interface User {
  attributes?: UserAttributes;
  /**
   * ID of the user.
   */
  id?: string;
  relationships?: UserResponseRelationships;
  type?: UsersType;
}

/**
 * Attributes of user object returned by the API.
 */
export interface UserAttributes {
  /**
   * Creation time of the user.
   */
  created_at?: string;
  /**
   * Whether the user is disabled.
   */
  disabled?: boolean;
  /**
   * Email of the user.
   */
  email?: string;
  /**
   * Handle of the user.
   */
  handle?: string;
  /**
   * URL of the user's icon.
   */
  icon?: string;
  /**
   * Time that the user was last modified.
   */
  modified_at?: string;
  /**
   * Name of the user.
   */
  name?: string | null;
  /**
   * Whether the user is a service account.
   */
  service_account?: boolean;
  /**
   * Status of the user.
   */
  status?: string;
  /**
   * Title of the user.
   */
  title?: string | null;
  /**
   * Whether the user is verified.
   */
  verified?: boolean;
}

/**
 * Attributes of the created user.
 */
export interface UserCreateAttributes {
  /**
   * The email of the user.
   */
  email: string;
  /**
   * The name of the user.
   */
  name?: string;
  /**
   * The title of the user.
   */
  title?: string;
}

/**
 * Object to create a user.
 */
export interface UserCreateData {
  attributes: UserCreateAttributes;
  relationships?: UserRelationships;
  type: UsersType;
}

/**
 * Create a user.
 */
export interface UserCreateRequest {
  data: UserCreateData;
}

/**
 * Object to create a user invitation.
 */
export interface UserInvitationData {
  relationships: UserInvitationRelationships;
  type: UserInvitationsType;
}

/**
 * Attributes of a user invitation.
 */
export interface UserInvitationDataAttributes {
  /**
   * Creation time of the user invitation.
   */
  created_at?: string;
  /**
   * Time of invitation expiration.
   */
  expires_at?: string;
  /**
   * Type of invitation.
   */
  invite_type?: string;
  /**
   * UUID of the user invitation.
   */
  uuid?: string;
}

/**
 * Relationships data for user invitation.
 */
export interface UserInvitationRelationships {
  user: RelationshipToUser;
}

/**
 * User invitation as returned by the API.
 */
export interface UserInvitationResponse {
  data?: UserInvitationResponseData;
}

/**
 * Object of a user invitation returned by the API.
 */
export interface UserInvitationResponseData {
  attributes?: UserInvitationDataAttributes;
  /**
   * ID of the user invitation.
   */
  id?: string;
  type?: UserInvitationsType;
}

/**
 * Object to invite users to join the organization.
 */
export interface UserInvitationsRequest {
  /**
   * List of user invitations.
   */
  data: UserInvitationData[];
}

/**
 * User invitations as returned by the API.
 */
export interface UserInvitationsResponse {
  /**
   * Array of user invitations.
   */
  data?: UserInvitationResponseData[];
}

/**
 * User invitations type.
 */
export type UserInvitationsType = "user_invitations";

/**
 * Relationships of the user object.
 */
export interface UserRelationships {
  roles?: RelationshipToRoles;
}

/**
 * Response containing information about a single user.
 */
export interface UserResponse {
  data?: User;
  /**
   * Array of objects related to the user.
   */
  included?: UserResponseIncludedItem[];
}

/**
 * An object related to a user.
 */
export type UserResponseIncludedItem = Organization | Permission | Role;

/**
 * Relationships of the user object returned by the API.
 */
export interface UserResponseRelationships {
  org?: RelationshipToOrganization;
  other_orgs?: RelationshipToOrganizations;
  other_users?: RelationshipToUsers;
  roles?: RelationshipToRoles;
}

/**
 * Attributes of the edited user.
 */
export interface UserUpdateAttributes {
  /**
   * If the user is enabled or disabled.
   */
  disabled?: boolean;
  /**
   * The email of the user.
   */
  email?: string;
  /**
   * The name of the user.
   */
  name?: string;
}

/**
 * Object to update a user.
 */
export interface UserUpdateData {
  attributes: UserUpdateAttributes;
  /**
   * ID of the user.
   */
  id: string;
  type: UsersType;
}

/**
 * Update a user.
 */
export interface UserUpdateRequest {
  data: UserUpdateData;
}

/**
 * Response containing information about multiple users.
 */
export interface UsersResponse {
  /**
   * Array of returned users.
   */
  data?: User[];
  /**
   * Array of objects related to the users.
   */
  included?: UserResponseIncludedItem[];
  meta?: ResponseMetaAttributes;
}

/**
 * Users resource type.
 */
export type UsersType = "users";

/**
 * Bad Request
 */
export type BadRequestResponseResponse = APIErrorResponse;

/**
 * Concurrent Modification
 */
export type ConcurrentModificationResponseResponse = APIErrorResponse;

/**
 * Conflict
 */
export type ConflictResponseResponse = APIErrorResponse;

/**
 * Forbidden
 */
export type ForbiddenResponseResponse = APIErrorResponse;

/**
 * Not Authorized
 */
export type NotAuthorizedResponseResponse = APIErrorResponse;

/**
 * Not Found
 */
export type NotFoundResponseResponse = APIErrorResponse;

/**
 * Too many requests
 */
export type TooManyRequestsResponseResponse = APIErrorResponse;

/**
 * Unauthorized
 */
export type UnauthorizedResponseResponse = APIErrorResponse;

export interface ListAPIKeysQueryParams {
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific page number to return.
   */
  "page[number]"?: number;
  /**
   * API key attribute used to sort results. Sort order is ascending
   * by default. In order to specify a descending sort, prefix the
   * attribute with a minus sign.
   */
  sort?: APIKeysSort;
  /**
   * Filter API keys by the specified string.
   */
  filter?: string;
  /**
   * Only include API keys created on or after the specified date.
   */
  "filter[created_at][start]"?: string;
  /**
   * Only include API keys created on or before the specified date.
   */
  "filter[created_at][end]"?: string;
  /**
   * Only include API keys modified on or after the specified date.
   */
  "filter[modified_at][start]"?: string;
  /**
   * Only include API keys modified on or before the specified date.
   */
  "filter[modified_at][end]"?: string;
  /**
   * Comma separated list of resource paths for related resources to include in the response. Supported resource paths are `created_by` and `modified_by`.
   */
  include?: string;
}

export type ListAPIKeysProps = Omit<GetProps<APIKeysResponse, APIErrorResponse, ListAPIKeysQueryParams, void>, "path">;

/**
 * Get all API keys
 * 
 * List all API keys available for your account.
 */
export const ListAPIKeys = (props: ListAPIKeysProps) => (
  <Get<APIKeysResponse, APIErrorResponse, ListAPIKeysQueryParams, void>
    path={`/api/v2/api_keys`}
    
    {...props}
  />
);

export type UseListAPIKeysProps = Omit<UseGetProps<APIKeysResponse, APIErrorResponse, ListAPIKeysQueryParams, void>, "path">;

/**
 * Get all API keys
 * 
 * List all API keys available for your account.
 */
export const useListAPIKeys = (props: UseListAPIKeysProps) => useGet<APIKeysResponse, APIErrorResponse, ListAPIKeysQueryParams, void>(`/api/v2/api_keys`, props);

/**
 * Get all API keys
 * 
 * List all API keys available for your account.
 */
export const listAPIKeysPromise = (props: ListAPIKeysQueryParams) => HttpGET<APIKeysResponse, ListAPIKeysQueryParams>('/api/v2/api_keys', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateAPIKeyProps = Omit<MutateProps<APIKeyResponse, APIErrorResponse, void, APIKeyCreateRequest, void>, "path" | "verb">;

/**
 * Create an API key
 * 
 * Create an API key.
 */
export const CreateAPIKey = (props: CreateAPIKeyProps) => (
  <Mutate<APIKeyResponse, APIErrorResponse, void, APIKeyCreateRequest, void>
    verb="POST"
    path={`/api/v2/api_keys`}
    
    {...props}
  />
);

export type UseCreateAPIKeyProps = Omit<UseMutateProps<APIKeyResponse, APIErrorResponse, void, APIKeyCreateRequest, void>, "path" | "verb">;

/**
 * Create an API key
 * 
 * Create an API key.
 */
export const useCreateAPIKey = (props: UseCreateAPIKeyProps) => useMutate<APIKeyResponse, APIErrorResponse, void, APIKeyCreateRequest, void>("POST", `/api/v2/api_keys`, props);

export type CreateAPIKeyPromiseProps = Omit<APIKeyCreateRequest, "_authentication_token">;
/**
 * Create an API key
 * 
 * Create an API key.
 */
export const createAPIKeyPromise = (props: CreateAPIKeyPromiseProps) => HttpPOST<APIKeyResponse, CreateAPIKeyPromiseProps>('/api/v2/api_keys')(props);


export type DeleteAPIKeyProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an API key
 * 
 * Delete an API key.
 */
export const DeleteAPIKey = (props: DeleteAPIKeyProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/api_keys`}
    
    {...props}
  />
);

export type UseDeleteAPIKeyProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an API key
 * 
 * Delete an API key.
 */
export const useDeleteAPIKey = (props: UseDeleteAPIKeyProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v2/api_keys`, {   ...props });


export interface GetAPIKeyQueryParams {
  /**
   * Comma separated list of resource paths for related resources to include in the response. Supported resource paths are `created_by` and `modified_by`.
   */
  include?: string;
}

export interface GetAPIKeyPathParams {
  /**
   * The ID of the API key.
   */
  api_key_id: string
}

export type GetAPIKeyProps = Omit<GetProps<APIKeyResponse, APIErrorResponse, GetAPIKeyQueryParams, GetAPIKeyPathParams>, "path"> & GetAPIKeyPathParams;

/**
 * Get API key
 * 
 * Get an API key.
 */
export const GetAPIKey = ({api_key_id, ...props}: GetAPIKeyProps) => (
  <Get<APIKeyResponse, APIErrorResponse, GetAPIKeyQueryParams, GetAPIKeyPathParams>
    path={`/api/v2/api_keys/${api_key_id}`}
    
    {...props}
  />
);

export type UseGetAPIKeyProps = Omit<UseGetProps<APIKeyResponse, APIErrorResponse, GetAPIKeyQueryParams, GetAPIKeyPathParams>, "path"> & GetAPIKeyPathParams;

/**
 * Get API key
 * 
 * Get an API key.
 */
export const useGetAPIKey = ({api_key_id, ...props}: UseGetAPIKeyProps) => useGet<APIKeyResponse, APIErrorResponse, GetAPIKeyQueryParams, GetAPIKeyPathParams>((paramsInPath: GetAPIKeyPathParams) => `/api/v2/api_keys/${paramsInPath.api_key_id}`, {  pathParams: { api_key_id }, ...props });

/**
 * Get API key
 * 
 * Get an API key.
 */
export const getAPIKeyPromise = (props: GetAPIKeyQueryParams) => HttpGET<APIKeyResponse, GetAPIKeyQueryParams>('/api/v2/api_keys/${api_key_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateAPIKeyPathParams {
  /**
   * The ID of the API key.
   */
  api_key_id: string
}

export type UpdateAPIKeyProps = Omit<MutateProps<APIKeyResponse, APIErrorResponse, void, APIKeyUpdateRequest, UpdateAPIKeyPathParams>, "path" | "verb"> & UpdateAPIKeyPathParams;

/**
 * Edit an API key
 * 
 * Update an API key.
 */
export const UpdateAPIKey = ({api_key_id, ...props}: UpdateAPIKeyProps) => (
  <Mutate<APIKeyResponse, APIErrorResponse, void, APIKeyUpdateRequest, UpdateAPIKeyPathParams>
    verb="PATCH"
    path={`/api/v2/api_keys/${api_key_id}`}
    
    {...props}
  />
);

export type UseUpdateAPIKeyProps = Omit<UseMutateProps<APIKeyResponse, APIErrorResponse, void, APIKeyUpdateRequest, UpdateAPIKeyPathParams>, "path" | "verb"> & UpdateAPIKeyPathParams;

/**
 * Edit an API key
 * 
 * Update an API key.
 */
export const useUpdateAPIKey = ({api_key_id, ...props}: UseUpdateAPIKeyProps) => useMutate<APIKeyResponse, APIErrorResponse, void, APIKeyUpdateRequest, UpdateAPIKeyPathParams>("PATCH", (paramsInPath: UpdateAPIKeyPathParams) => `/api/v2/api_keys/${paramsInPath.api_key_id}`, {  pathParams: { api_key_id }, ...props });


export interface ListApplicationKeysQueryParams {
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific page number to return.
   */
  "page[number]"?: number;
  /**
   * Application key attribute used to sort results. Sort order is ascending
   * by default. In order to specify a descending sort, prefix the
   * attribute with a minus sign.
   */
  sort?: ApplicationKeysSort;
  /**
   * Filter application keys by the specified string.
   */
  filter?: string;
  /**
   * Only include application keys created on or after the specified date.
   */
  "filter[created_at][start]"?: string;
  /**
   * Only include application keys created on or before the specified date.
   */
  "filter[created_at][end]"?: string;
}

export type ListApplicationKeysProps = Omit<GetProps<ListApplicationKeysResponse, APIErrorResponse, ListApplicationKeysQueryParams, void>, "path">;

/**
 * Get all application keys
 * 
 * List all application keys available for your org
 */
export const ListApplicationKeys = (props: ListApplicationKeysProps) => (
  <Get<ListApplicationKeysResponse, APIErrorResponse, ListApplicationKeysQueryParams, void>
    path={`/api/v2/application_keys`}
    
    {...props}
  />
);

export type UseListApplicationKeysProps = Omit<UseGetProps<ListApplicationKeysResponse, APIErrorResponse, ListApplicationKeysQueryParams, void>, "path">;

/**
 * Get all application keys
 * 
 * List all application keys available for your org
 */
export const useListApplicationKeys = (props: UseListApplicationKeysProps) => useGet<ListApplicationKeysResponse, APIErrorResponse, ListApplicationKeysQueryParams, void>(`/api/v2/application_keys`, props);

/**
 * Get all application keys
 * 
 * List all application keys available for your org
 */
export const listApplicationKeysPromise = (props: ListApplicationKeysQueryParams) => HttpGET<ListApplicationKeysResponse, ListApplicationKeysQueryParams>('/api/v2/application_keys', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type DeleteApplicationKeyProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an application key
 * 
 * Delete an application key
 */
export const DeleteApplicationKey = (props: DeleteApplicationKeyProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/application_keys`}
    
    {...props}
  />
);

export type UseDeleteApplicationKeyProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an application key
 * 
 * Delete an application key
 */
export const useDeleteApplicationKey = (props: UseDeleteApplicationKeyProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v2/application_keys`, {   ...props });


export interface GetApplicationKeyQueryParams {
  /**
   * Resource path for related resources to include in the response. Only `owned_by` is supported.
   */
  include?: string;
}

export interface GetApplicationKeyPathParams {
  /**
   * The ID of the application key.
   */
  app_key_id: string
}

export type GetApplicationKeyProps = Omit<GetProps<ApplicationKeyResponse, APIErrorResponse, GetApplicationKeyQueryParams, GetApplicationKeyPathParams>, "path"> & GetApplicationKeyPathParams;

/**
 * Get an application key
 * 
 * Get an application key for your org.
 */
export const GetApplicationKey = ({app_key_id, ...props}: GetApplicationKeyProps) => (
  <Get<ApplicationKeyResponse, APIErrorResponse, GetApplicationKeyQueryParams, GetApplicationKeyPathParams>
    path={`/api/v2/application_keys/${app_key_id}`}
    
    {...props}
  />
);

export type UseGetApplicationKeyProps = Omit<UseGetProps<ApplicationKeyResponse, APIErrorResponse, GetApplicationKeyQueryParams, GetApplicationKeyPathParams>, "path"> & GetApplicationKeyPathParams;

/**
 * Get an application key
 * 
 * Get an application key for your org.
 */
export const useGetApplicationKey = ({app_key_id, ...props}: UseGetApplicationKeyProps) => useGet<ApplicationKeyResponse, APIErrorResponse, GetApplicationKeyQueryParams, GetApplicationKeyPathParams>((paramsInPath: GetApplicationKeyPathParams) => `/api/v2/application_keys/${paramsInPath.app_key_id}`, {  pathParams: { app_key_id }, ...props });

/**
 * Get an application key
 * 
 * Get an application key for your org.
 */
export const getApplicationKeyPromise = (props: GetApplicationKeyQueryParams) => HttpGET<ApplicationKeyResponse, GetApplicationKeyQueryParams>('/api/v2/application_keys/${app_key_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateApplicationKeyPathParams {
  /**
   * The ID of the application key.
   */
  app_key_id: string
}

export type UpdateApplicationKeyProps = Omit<MutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateApplicationKeyPathParams>, "path" | "verb"> & UpdateApplicationKeyPathParams;

/**
 * Edit an application key
 * 
 * Edit an application key
 */
export const UpdateApplicationKey = ({app_key_id, ...props}: UpdateApplicationKeyProps) => (
  <Mutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateApplicationKeyPathParams>
    verb="PATCH"
    path={`/api/v2/application_keys/${app_key_id}`}
    
    {...props}
  />
);

export type UseUpdateApplicationKeyProps = Omit<UseMutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateApplicationKeyPathParams>, "path" | "verb"> & UpdateApplicationKeyPathParams;

/**
 * Edit an application key
 * 
 * Edit an application key
 */
export const useUpdateApplicationKey = ({app_key_id, ...props}: UseUpdateApplicationKeyProps) => useMutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateApplicationKeyPathParams>("PATCH", (paramsInPath: UpdateApplicationKeyPathParams) => `/api/v2/application_keys/${paramsInPath.app_key_id}`, {  pathParams: { app_key_id }, ...props });


export interface ListCurrentUserApplicationKeysQueryParams {
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific page number to return.
   */
  "page[number]"?: number;
  /**
   * Application key attribute used to sort results. Sort order is ascending
   * by default. In order to specify a descending sort, prefix the
   * attribute with a minus sign.
   */
  sort?: ApplicationKeysSort;
  /**
   * Filter application keys by the specified string.
   */
  filter?: string;
  /**
   * Only include application keys created on or after the specified date.
   */
  "filter[created_at][start]"?: string;
  /**
   * Only include application keys created on or before the specified date.
   */
  "filter[created_at][end]"?: string;
}

export type ListCurrentUserApplicationKeysProps = Omit<GetProps<ListApplicationKeysResponse, APIErrorResponse, ListCurrentUserApplicationKeysQueryParams, void>, "path">;

/**
 * Get all application keys owned by current user
 * 
 * List all application keys available for current user
 */
export const ListCurrentUserApplicationKeys = (props: ListCurrentUserApplicationKeysProps) => (
  <Get<ListApplicationKeysResponse, APIErrorResponse, ListCurrentUserApplicationKeysQueryParams, void>
    path={`/api/v2/current_user/application_keys`}
    
    {...props}
  />
);

export type UseListCurrentUserApplicationKeysProps = Omit<UseGetProps<ListApplicationKeysResponse, APIErrorResponse, ListCurrentUserApplicationKeysQueryParams, void>, "path">;

/**
 * Get all application keys owned by current user
 * 
 * List all application keys available for current user
 */
export const useListCurrentUserApplicationKeys = (props: UseListCurrentUserApplicationKeysProps) => useGet<ListApplicationKeysResponse, APIErrorResponse, ListCurrentUserApplicationKeysQueryParams, void>(`/api/v2/current_user/application_keys`, props);

/**
 * Get all application keys owned by current user
 * 
 * List all application keys available for current user
 */
export const listCurrentUserApplicationKeysPromise = (props: ListCurrentUserApplicationKeysQueryParams) => HttpGET<ListApplicationKeysResponse, ListCurrentUserApplicationKeysQueryParams>('/api/v2/current_user/application_keys', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateCurrentUserApplicationKeyProps = Omit<MutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyCreateRequest, void>, "path" | "verb">;

/**
 * Create an application key for current user
 * 
 * Create an application key for current user
 */
export const CreateCurrentUserApplicationKey = (props: CreateCurrentUserApplicationKeyProps) => (
  <Mutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyCreateRequest, void>
    verb="POST"
    path={`/api/v2/current_user/application_keys`}
    
    {...props}
  />
);

export type UseCreateCurrentUserApplicationKeyProps = Omit<UseMutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyCreateRequest, void>, "path" | "verb">;

/**
 * Create an application key for current user
 * 
 * Create an application key for current user
 */
export const useCreateCurrentUserApplicationKey = (props: UseCreateCurrentUserApplicationKeyProps) => useMutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyCreateRequest, void>("POST", `/api/v2/current_user/application_keys`, props);

export type CreateCurrentUserApplicationKeyPromiseProps = Omit<ApplicationKeyCreateRequest, "_authentication_token">;
/**
 * Create an application key for current user
 * 
 * Create an application key for current user
 */
export const createCurrentUserApplicationKeyPromise = (props: CreateCurrentUserApplicationKeyPromiseProps) => HttpPOST<ApplicationKeyResponse, CreateCurrentUserApplicationKeyPromiseProps>('/api/v2/current_user/application_keys')(props);


export type DeleteCurrentUserApplicationKeyProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an application key owned by current user
 * 
 * Delete an application key owned by current user
 */
export const DeleteCurrentUserApplicationKey = (props: DeleteCurrentUserApplicationKeyProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/current_user/application_keys`}
    
    {...props}
  />
);

export type UseDeleteCurrentUserApplicationKeyProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an application key owned by current user
 * 
 * Delete an application key owned by current user
 */
export const useDeleteCurrentUserApplicationKey = (props: UseDeleteCurrentUserApplicationKeyProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v2/current_user/application_keys`, {   ...props });


export interface GetCurrentUserApplicationKeyPathParams {
  /**
   * The ID of the application key.
   */
  app_key_id: string
}

export type GetCurrentUserApplicationKeyProps = Omit<GetProps<ApplicationKeyResponse, APIErrorResponse, void, GetCurrentUserApplicationKeyPathParams>, "path"> & GetCurrentUserApplicationKeyPathParams;

/**
 * Get one application key owned by current user
 * 
 * Get an application key owned by current user
 */
export const GetCurrentUserApplicationKey = ({app_key_id, ...props}: GetCurrentUserApplicationKeyProps) => (
  <Get<ApplicationKeyResponse, APIErrorResponse, void, GetCurrentUserApplicationKeyPathParams>
    path={`/api/v2/current_user/application_keys/${app_key_id}`}
    
    {...props}
  />
);

export type UseGetCurrentUserApplicationKeyProps = Omit<UseGetProps<ApplicationKeyResponse, APIErrorResponse, void, GetCurrentUserApplicationKeyPathParams>, "path"> & GetCurrentUserApplicationKeyPathParams;

/**
 * Get one application key owned by current user
 * 
 * Get an application key owned by current user
 */
export const useGetCurrentUserApplicationKey = ({app_key_id, ...props}: UseGetCurrentUserApplicationKeyProps) => useGet<ApplicationKeyResponse, APIErrorResponse, void, GetCurrentUserApplicationKeyPathParams>((paramsInPath: GetCurrentUserApplicationKeyPathParams) => `/api/v2/current_user/application_keys/${paramsInPath.app_key_id}`, {  pathParams: { app_key_id }, ...props });

/**
 * Get one application key owned by current user
 * 
 * Get an application key owned by current user
 */
export const getCurrentUserApplicationKeyPromise = (props: void) => HttpGET<ApplicationKeyResponse, void>('/api/v2/current_user/application_keys/${app_key_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateCurrentUserApplicationKeyPathParams {
  /**
   * The ID of the application key.
   */
  app_key_id: string
}

export type UpdateCurrentUserApplicationKeyProps = Omit<MutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateCurrentUserApplicationKeyPathParams>, "path" | "verb"> & UpdateCurrentUserApplicationKeyPathParams;

/**
 * Edit an application key owned by current user
 * 
 * Edit an application key owned by current user
 */
export const UpdateCurrentUserApplicationKey = ({app_key_id, ...props}: UpdateCurrentUserApplicationKeyProps) => (
  <Mutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateCurrentUserApplicationKeyPathParams>
    verb="PATCH"
    path={`/api/v2/current_user/application_keys/${app_key_id}`}
    
    {...props}
  />
);

export type UseUpdateCurrentUserApplicationKeyProps = Omit<UseMutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateCurrentUserApplicationKeyPathParams>, "path" | "verb"> & UpdateCurrentUserApplicationKeyPathParams;

/**
 * Edit an application key owned by current user
 * 
 * Edit an application key owned by current user
 */
export const useUpdateCurrentUserApplicationKey = ({app_key_id, ...props}: UseUpdateCurrentUserApplicationKeyProps) => useMutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateCurrentUserApplicationKeyPathParams>("PATCH", (paramsInPath: UpdateCurrentUserApplicationKeyPathParams) => `/api/v2/current_user/application_keys/${paramsInPath.app_key_id}`, {  pathParams: { app_key_id }, ...props });


export interface DeleteDashboardListItemsPathParams {
  /**
   * ID of the dashboard list to delete items from.
   */
  dashboard_list_id: number
}

export type DeleteDashboardListItemsProps = Omit<MutateProps<DashboardListDeleteItemsResponse, APIErrorResponse, void, DashboardListDeleteItemsRequest, DeleteDashboardListItemsPathParams>, "path" | "verb"> & DeleteDashboardListItemsPathParams;

/**
 * Delete items from a dashboard list
 * 
 * Delete dashboards from an existing dashboard list.
 */
export const DeleteDashboardListItems = ({dashboard_list_id, ...props}: DeleteDashboardListItemsProps) => (
  <Mutate<DashboardListDeleteItemsResponse, APIErrorResponse, void, DashboardListDeleteItemsRequest, DeleteDashboardListItemsPathParams>
    verb="DELETE"
    path={`/api/v2/dashboard/lists/manual/${dashboard_list_id}/dashboards`}
    
    {...props}
  />
);

export type UseDeleteDashboardListItemsProps = Omit<UseMutateProps<DashboardListDeleteItemsResponse, APIErrorResponse, void, DashboardListDeleteItemsRequest, DeleteDashboardListItemsPathParams>, "path" | "verb"> & DeleteDashboardListItemsPathParams;

/**
 * Delete items from a dashboard list
 * 
 * Delete dashboards from an existing dashboard list.
 */
export const useDeleteDashboardListItems = ({dashboard_list_id, ...props}: UseDeleteDashboardListItemsProps) => useMutate<DashboardListDeleteItemsResponse, APIErrorResponse, void, DashboardListDeleteItemsRequest, DeleteDashboardListItemsPathParams>("DELETE", (paramsInPath: DeleteDashboardListItemsPathParams) => `/api/v2/dashboard/lists/manual/${paramsInPath.dashboard_list_id}/dashboards`, {  pathParams: { dashboard_list_id }, ...props });


export interface GetDashboardListItemsPathParams {
  /**
   * ID of the dashboard list to get items from.
   */
  dashboard_list_id: number
}

export type GetDashboardListItemsProps = Omit<GetProps<DashboardListItems, APIErrorResponse, void, GetDashboardListItemsPathParams>, "path"> & GetDashboardListItemsPathParams;

/**
 * Get items of a Dashboard List
 * 
 * Fetch the dashboard lists dashboard definitions.
 */
export const GetDashboardListItems = ({dashboard_list_id, ...props}: GetDashboardListItemsProps) => (
  <Get<DashboardListItems, APIErrorResponse, void, GetDashboardListItemsPathParams>
    path={`/api/v2/dashboard/lists/manual/${dashboard_list_id}/dashboards`}
    
    {...props}
  />
);

export type UseGetDashboardListItemsProps = Omit<UseGetProps<DashboardListItems, APIErrorResponse, void, GetDashboardListItemsPathParams>, "path"> & GetDashboardListItemsPathParams;

/**
 * Get items of a Dashboard List
 * 
 * Fetch the dashboard lists dashboard definitions.
 */
export const useGetDashboardListItems = ({dashboard_list_id, ...props}: UseGetDashboardListItemsProps) => useGet<DashboardListItems, APIErrorResponse, void, GetDashboardListItemsPathParams>((paramsInPath: GetDashboardListItemsPathParams) => `/api/v2/dashboard/lists/manual/${paramsInPath.dashboard_list_id}/dashboards`, {  pathParams: { dashboard_list_id }, ...props });

/**
 * Get items of a Dashboard List
 * 
 * Fetch the dashboard lists dashboard definitions.
 */
export const getDashboardListItemsPromise = (props: void) => HttpGET<DashboardListItems, void>('/api/v2/dashboard/lists/manual/${dashboard_list_id}/dashboards', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface CreateDashboardListItemsPathParams {
  /**
   * ID of the dashboard list to add items to.
   */
  dashboard_list_id: number
}

export type CreateDashboardListItemsProps = Omit<MutateProps<DashboardListAddItemsResponse, APIErrorResponse, void, DashboardListAddItemsRequest, CreateDashboardListItemsPathParams>, "path" | "verb"> & CreateDashboardListItemsPathParams;

/**
 * Add Items to a Dashboard List
 * 
 * Add dashboards to an existing dashboard list.
 */
export const CreateDashboardListItems = ({dashboard_list_id, ...props}: CreateDashboardListItemsProps) => (
  <Mutate<DashboardListAddItemsResponse, APIErrorResponse, void, DashboardListAddItemsRequest, CreateDashboardListItemsPathParams>
    verb="POST"
    path={`/api/v2/dashboard/lists/manual/${dashboard_list_id}/dashboards`}
    
    {...props}
  />
);

export type UseCreateDashboardListItemsProps = Omit<UseMutateProps<DashboardListAddItemsResponse, APIErrorResponse, void, DashboardListAddItemsRequest, CreateDashboardListItemsPathParams>, "path" | "verb"> & CreateDashboardListItemsPathParams;

/**
 * Add Items to a Dashboard List
 * 
 * Add dashboards to an existing dashboard list.
 */
export const useCreateDashboardListItems = ({dashboard_list_id, ...props}: UseCreateDashboardListItemsProps) => useMutate<DashboardListAddItemsResponse, APIErrorResponse, void, DashboardListAddItemsRequest, CreateDashboardListItemsPathParams>("POST", (paramsInPath: CreateDashboardListItemsPathParams) => `/api/v2/dashboard/lists/manual/${paramsInPath.dashboard_list_id}/dashboards`, {  pathParams: { dashboard_list_id }, ...props });

export type CreateDashboardListItemsPromiseProps = Omit<DashboardListAddItemsRequest, "_authentication_token">;
/**
 * Add Items to a Dashboard List
 * 
 * Add dashboards to an existing dashboard list.
 */
export const createDashboardListItemsPromise = (props: CreateDashboardListItemsPromiseProps) => HttpPOST<DashboardListAddItemsResponse, CreateDashboardListItemsPromiseProps>('/api/v2/dashboard/lists/manual/${dashboard_list_id}/dashboards')(props);


export interface UpdateDashboardListItemsPathParams {
  /**
   * ID of the dashboard list to update items from.
   */
  dashboard_list_id: number
}

export type UpdateDashboardListItemsProps = Omit<MutateProps<DashboardListUpdateItemsResponse, APIErrorResponse, void, DashboardListUpdateItemsRequest, UpdateDashboardListItemsPathParams>, "path" | "verb"> & UpdateDashboardListItemsPathParams;

/**
 * Update items of a dashboard list
 * 
 * Update dashboards of an existing dashboard list.
 */
export const UpdateDashboardListItems = ({dashboard_list_id, ...props}: UpdateDashboardListItemsProps) => (
  <Mutate<DashboardListUpdateItemsResponse, APIErrorResponse, void, DashboardListUpdateItemsRequest, UpdateDashboardListItemsPathParams>
    verb="PUT"
    path={`/api/v2/dashboard/lists/manual/${dashboard_list_id}/dashboards`}
    
    {...props}
  />
);

export type UseUpdateDashboardListItemsProps = Omit<UseMutateProps<DashboardListUpdateItemsResponse, APIErrorResponse, void, DashboardListUpdateItemsRequest, UpdateDashboardListItemsPathParams>, "path" | "verb"> & UpdateDashboardListItemsPathParams;

/**
 * Update items of a dashboard list
 * 
 * Update dashboards of an existing dashboard list.
 */
export const useUpdateDashboardListItems = ({dashboard_list_id, ...props}: UseUpdateDashboardListItemsProps) => useMutate<DashboardListUpdateItemsResponse, APIErrorResponse, void, DashboardListUpdateItemsRequest, UpdateDashboardListItemsPathParams>("PUT", (paramsInPath: UpdateDashboardListItemsPathParams) => `/api/v2/dashboard/lists/manual/${paramsInPath.dashboard_list_id}/dashboards`, {  pathParams: { dashboard_list_id }, ...props });


export interface ListIncidentsQueryParams {
  /**
   * Specifies which types of related objects should be included in the response.
   */
  include?: IncidentRelatedObject[];
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific offset to use as the beginning of the returned page.
   */
  "page[offset]"?: number;
}

export type ListIncidentsProps = Omit<GetProps<IncidentsResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentsQueryParams, void>, "path">;

/**
 * Get a list of incidents
 * 
 * Get all incidents for the user's organization.
 */
export const ListIncidents = (props: ListIncidentsProps) => (
  <Get<IncidentsResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentsQueryParams, void>
    path={`/api/v2/incidents`}
    
    {...props}
  />
);

export type UseListIncidentsProps = Omit<UseGetProps<IncidentsResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentsQueryParams, void>, "path">;

/**
 * Get a list of incidents
 * 
 * Get all incidents for the user's organization.
 */
export const useListIncidents = (props: UseListIncidentsProps) => useGet<IncidentsResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentsQueryParams, void>(`/api/v2/incidents`, props);

/**
 * Get a list of incidents
 * 
 * Get all incidents for the user's organization.
 */
export const listIncidentsPromise = (props: ListIncidentsQueryParams) => HttpGET<IncidentsResponse, ListIncidentsQueryParams>('/api/v2/incidents', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateIncidentProps = Omit<MutateProps<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentCreateRequest, void>, "path" | "verb">;

/**
 * Create an incident
 * 
 * Create an incident.
 */
export const CreateIncident = (props: CreateIncidentProps) => (
  <Mutate<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentCreateRequest, void>
    verb="POST"
    path={`/api/v2/incidents`}
    
    {...props}
  />
);

export type UseCreateIncidentProps = Omit<UseMutateProps<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentCreateRequest, void>, "path" | "verb">;

/**
 * Create an incident
 * 
 * Create an incident.
 */
export const useCreateIncident = (props: UseCreateIncidentProps) => useMutate<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentCreateRequest, void>("POST", `/api/v2/incidents`, props);

export type CreateIncidentPromiseProps = Omit<IncidentCreateRequest, "_authentication_token">;
/**
 * Create an incident
 * 
 * Create an incident.
 */
export const createIncidentPromise = (props: CreateIncidentPromiseProps) => HttpPOST<IncidentResponse, CreateIncidentPromiseProps>('/api/v2/incidents')(props);


export type DeleteIncidentProps = Omit<MutateProps<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an existing incident
 * 
 * Deletes an existing incident from the users organization.
 */
export const DeleteIncident = (props: DeleteIncidentProps) => (
  <Mutate<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/incidents`}
    
    {...props}
  />
);

export type UseDeleteIncidentProps = Omit<UseMutateProps<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an existing incident
 * 
 * Deletes an existing incident from the users organization.
 */
export const useDeleteIncident = (props: UseDeleteIncidentProps) => useMutate<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>("DELETE", `/api/v2/incidents`, {   ...props });


export interface GetIncidentQueryParams {
  /**
   * Specifies which types of related objects should be included in the response.
   */
  include?: IncidentRelatedObject[];
}

export interface GetIncidentPathParams {
  /**
   * The UUID the incident.
   */
  incident_id: string
}

export type GetIncidentProps = Omit<GetProps<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentQueryParams, GetIncidentPathParams>, "path"> & GetIncidentPathParams;

/**
 * Get the details of an incident
 * 
 * Get the details of an incident by `incident_id`.
 */
export const GetIncident = ({incident_id, ...props}: GetIncidentProps) => (
  <Get<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentQueryParams, GetIncidentPathParams>
    path={`/api/v2/incidents/${incident_id}`}
    
    {...props}
  />
);

export type UseGetIncidentProps = Omit<UseGetProps<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentQueryParams, GetIncidentPathParams>, "path"> & GetIncidentPathParams;

/**
 * Get the details of an incident
 * 
 * Get the details of an incident by `incident_id`.
 */
export const useGetIncident = ({incident_id, ...props}: UseGetIncidentProps) => useGet<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentQueryParams, GetIncidentPathParams>((paramsInPath: GetIncidentPathParams) => `/api/v2/incidents/${paramsInPath.incident_id}`, {  pathParams: { incident_id }, ...props });

/**
 * Get the details of an incident
 * 
 * Get the details of an incident by `incident_id`.
 */
export const getIncidentPromise = (props: GetIncidentQueryParams) => HttpGET<IncidentResponse, GetIncidentQueryParams>('/api/v2/incidents/${incident_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateIncidentPathParams {
  /**
   * The UUID the incident.
   */
  incident_id: string
}

export type UpdateIncidentProps = Omit<MutateProps<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentUpdateRequest, UpdateIncidentPathParams>, "path" | "verb"> & UpdateIncidentPathParams;

/**
 * Update an existing incident
 * 
 * Updates an incident. Provide only the attributes that should be updated as this request is a partial update.
 */
export const UpdateIncident = ({incident_id, ...props}: UpdateIncidentProps) => (
  <Mutate<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentUpdateRequest, UpdateIncidentPathParams>
    verb="PATCH"
    path={`/api/v2/incidents/${incident_id}`}
    
    {...props}
  />
);

export type UseUpdateIncidentProps = Omit<UseMutateProps<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentUpdateRequest, UpdateIncidentPathParams>, "path" | "verb"> & UpdateIncidentPathParams;

/**
 * Update an existing incident
 * 
 * Updates an incident. Provide only the attributes that should be updated as this request is a partial update.
 */
export const useUpdateIncident = ({incident_id, ...props}: UseUpdateIncidentProps) => useMutate<IncidentResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentUpdateRequest, UpdateIncidentPathParams>("PATCH", (paramsInPath: UpdateIncidentPathParams) => `/api/v2/incidents/${paramsInPath.incident_id}`, {  pathParams: { incident_id }, ...props });


export interface SubmitLogResponse {[key: string]: any}

export interface SubmitLogQueryParams {
  /**
   * Log tags can be passed as query parameters with `text/plain` content type.
   */
  ddtags?: string;
}

export type SubmitLogProps = Omit<MutateProps<SubmitLogResponse, HTTPLogErrors, SubmitLogQueryParams, HTTPLog, void>, "path" | "verb">;

/**
 * Send logs
 * 
 * Send your logs to your Datadog platform over HTTP. Limits per HTTP request are:
 * 
 * - Maximum content size per payload (uncompressed): 5MB
 * - Maximum size for a single log: 1MB
 * - Maximum array size if sending multiple logs in an array: 1000 entries
 * 
 * Any log exceeding 1MB is accepted and truncated by Datadog:
 * - For a single log request, the API truncates the log at 1MB and returns a 2xx.
 * - For a multi-logs request, the API processes all logs, truncates only logs larger than 1MB, and returns a 2xx.
 * 
 * Datadog recommends sending your logs compressed.
 * Add the `Content-Encoding: gzip` header to the request when sending compressed logs.
 * 
 * The status codes answered by the HTTP API are:
 * - 202: Accepted: the request has been accepted for processing
 * - 400: Bad request (likely an issue in the payload formatting)
 * - 401: Unauthorized (likely a missing API Key)
 * - 403: Permission issue (likely using an invalid API Key)
 * - 408: Request Timeout, request should be retried after some time
 * - 413: Payload too large (batch is above 5MB uncompressed)
 * - 429: Too Many Requests, request should be retried after some time
 * - 500: Internal Server Error, the server encountered an unexpected condition that prevented it from fulfilling the request, request should be retried after some time
 * - 503: Service Unavailable, the server is not ready to handle the request probably because it is overloaded, request should be retried after some time
 */
export const SubmitLog = (props: SubmitLogProps) => (
  <Mutate<SubmitLogResponse, HTTPLogErrors, SubmitLogQueryParams, HTTPLog, void>
    verb="POST"
    path={`/api/v2/logs`}
    
    {...props}
  />
);

export type UseSubmitLogProps = Omit<UseMutateProps<SubmitLogResponse, HTTPLogErrors, SubmitLogQueryParams, HTTPLog, void>, "path" | "verb">;

/**
 * Send logs
 * 
 * Send your logs to your Datadog platform over HTTP. Limits per HTTP request are:
 * 
 * - Maximum content size per payload (uncompressed): 5MB
 * - Maximum size for a single log: 1MB
 * - Maximum array size if sending multiple logs in an array: 1000 entries
 * 
 * Any log exceeding 1MB is accepted and truncated by Datadog:
 * - For a single log request, the API truncates the log at 1MB and returns a 2xx.
 * - For a multi-logs request, the API processes all logs, truncates only logs larger than 1MB, and returns a 2xx.
 * 
 * Datadog recommends sending your logs compressed.
 * Add the `Content-Encoding: gzip` header to the request when sending compressed logs.
 * 
 * The status codes answered by the HTTP API are:
 * - 202: Accepted: the request has been accepted for processing
 * - 400: Bad request (likely an issue in the payload formatting)
 * - 401: Unauthorized (likely a missing API Key)
 * - 403: Permission issue (likely using an invalid API Key)
 * - 408: Request Timeout, request should be retried after some time
 * - 413: Payload too large (batch is above 5MB uncompressed)
 * - 429: Too Many Requests, request should be retried after some time
 * - 500: Internal Server Error, the server encountered an unexpected condition that prevented it from fulfilling the request, request should be retried after some time
 * - 503: Service Unavailable, the server is not ready to handle the request probably because it is overloaded, request should be retried after some time
 */
export const useSubmitLog = (props: UseSubmitLogProps) => useMutate<SubmitLogResponse, HTTPLogErrors, SubmitLogQueryParams, HTTPLog, void>("POST", `/api/v2/logs`, props);

export type SubmitLogPromiseProps = Omit<HTTPLog, "_authentication_token">;
/**
 * Send logs
 * 
 * Send your logs to your Datadog platform over HTTP. Limits per HTTP request are:
 * 
 * - Maximum content size per payload (uncompressed): 5MB
 * - Maximum size for a single log: 1MB
 * - Maximum array size if sending multiple logs in an array: 1000 entries
 * 
 * Any log exceeding 1MB is accepted and truncated by Datadog:
 * - For a single log request, the API truncates the log at 1MB and returns a 2xx.
 * - For a multi-logs request, the API processes all logs, truncates only logs larger than 1MB, and returns a 2xx.
 * 
 * Datadog recommends sending your logs compressed.
 * Add the `Content-Encoding: gzip` header to the request when sending compressed logs.
 * 
 * The status codes answered by the HTTP API are:
 * - 202: Accepted: the request has been accepted for processing
 * - 400: Bad request (likely an issue in the payload formatting)
 * - 401: Unauthorized (likely a missing API Key)
 * - 403: Permission issue (likely using an invalid API Key)
 * - 408: Request Timeout, request should be retried after some time
 * - 413: Payload too large (batch is above 5MB uncompressed)
 * - 429: Too Many Requests, request should be retried after some time
 * - 500: Internal Server Error, the server encountered an unexpected condition that prevented it from fulfilling the request, request should be retried after some time
 * - 503: Service Unavailable, the server is not ready to handle the request probably because it is overloaded, request should be retried after some time
 */
export const submitLogPromise = (props: SubmitLogPromiseProps) => HttpPOST<SubmitLogResponse, SubmitLogPromiseProps>('/api/v2/logs')(props);


export type AggregateLogsProps = Omit<MutateProps<LogsAggregateResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, LogsAggregateRequest, void>, "path" | "verb">;

/**
 * Aggregate events
 * 
 * The API endpoint to aggregate events into buckets and compute metrics and timeseries.
 */
export const AggregateLogs = (props: AggregateLogsProps) => (
  <Mutate<LogsAggregateResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, LogsAggregateRequest, void>
    verb="POST"
    path={`/api/v2/logs/analytics/aggregate`}
    
    {...props}
  />
);

export type UseAggregateLogsProps = Omit<UseMutateProps<LogsAggregateResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, LogsAggregateRequest, void>, "path" | "verb">;

/**
 * Aggregate events
 * 
 * The API endpoint to aggregate events into buckets and compute metrics and timeseries.
 */
export const useAggregateLogs = (props: UseAggregateLogsProps) => useMutate<LogsAggregateResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, LogsAggregateRequest, void>("POST", `/api/v2/logs/analytics/aggregate`, props);

export type AggregateLogsPromiseProps = Omit<LogsAggregateRequest, "_authentication_token">;
/**
 * Aggregate events
 * 
 * The API endpoint to aggregate events into buckets and compute metrics and timeseries.
 */
export const aggregateLogsPromise = (props: AggregateLogsPromiseProps) => HttpPOST<LogsAggregateResponse, AggregateLogsPromiseProps>('/api/v2/logs/analytics/aggregate')(props);


export type GetLogsArchiveOrderProps = Omit<GetProps<LogsArchiveOrder, APIErrorResponse, void, void>, "path">;

/**
 * Get archive order
 * 
 * Get the current order of your archives.
 * This endpoint takes no JSON arguments.
 */
export const GetLogsArchiveOrder = (props: GetLogsArchiveOrderProps) => (
  <Get<LogsArchiveOrder, APIErrorResponse, void, void>
    path={`/api/v2/logs/config/archive-order`}
    
    {...props}
  />
);

export type UseGetLogsArchiveOrderProps = Omit<UseGetProps<LogsArchiveOrder, APIErrorResponse, void, void>, "path">;

/**
 * Get archive order
 * 
 * Get the current order of your archives.
 * This endpoint takes no JSON arguments.
 */
export const useGetLogsArchiveOrder = (props: UseGetLogsArchiveOrderProps) => useGet<LogsArchiveOrder, APIErrorResponse, void, void>(`/api/v2/logs/config/archive-order`, props);

/**
 * Get archive order
 * 
 * Get the current order of your archives.
 * This endpoint takes no JSON arguments.
 */
export const getLogsArchiveOrderPromise = (props: void) => HttpGET<LogsArchiveOrder, void>('/api/v2/logs/config/archive-order', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type UpdateLogsArchiveOrderProps = Omit<MutateProps<LogsArchiveOrder, APIErrorResponse, void, LogsArchiveOrder, void>, "path" | "verb">;

/**
 * Update archive order
 * 
 * Update the order of your archives. Since logs are processed sequentially, reordering an archive may change
 * the structure and content of the data processed by other archives.
 * 
 * **Note**: Using the `PUT` method updates your archive's order by replacing the current order
 * with the new one.
 */
export const UpdateLogsArchiveOrder = (props: UpdateLogsArchiveOrderProps) => (
  <Mutate<LogsArchiveOrder, APIErrorResponse, void, LogsArchiveOrder, void>
    verb="PUT"
    path={`/api/v2/logs/config/archive-order`}
    
    {...props}
  />
);

export type UseUpdateLogsArchiveOrderProps = Omit<UseMutateProps<LogsArchiveOrder, APIErrorResponse, void, LogsArchiveOrder, void>, "path" | "verb">;

/**
 * Update archive order
 * 
 * Update the order of your archives. Since logs are processed sequentially, reordering an archive may change
 * the structure and content of the data processed by other archives.
 * 
 * **Note**: Using the `PUT` method updates your archive's order by replacing the current order
 * with the new one.
 */
export const useUpdateLogsArchiveOrder = (props: UseUpdateLogsArchiveOrderProps) => useMutate<LogsArchiveOrder, APIErrorResponse, void, LogsArchiveOrder, void>("PUT", `/api/v2/logs/config/archive-order`, props);


export type ListLogsArchivesProps = Omit<GetProps<LogsArchives, APIErrorResponse, void, void>, "path">;

/**
 * Get all archives
 * 
 * Get the list of configured logs archives with their definitions.
 */
export const ListLogsArchives = (props: ListLogsArchivesProps) => (
  <Get<LogsArchives, APIErrorResponse, void, void>
    path={`/api/v2/logs/config/archives`}
    
    {...props}
  />
);

export type UseListLogsArchivesProps = Omit<UseGetProps<LogsArchives, APIErrorResponse, void, void>, "path">;

/**
 * Get all archives
 * 
 * Get the list of configured logs archives with their definitions.
 */
export const useListLogsArchives = (props: UseListLogsArchivesProps) => useGet<LogsArchives, APIErrorResponse, void, void>(`/api/v2/logs/config/archives`, props);

/**
 * Get all archives
 * 
 * Get the list of configured logs archives with their definitions.
 */
export const listLogsArchivesPromise = (props: void) => HttpGET<LogsArchives, void>('/api/v2/logs/config/archives', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateLogsArchiveProps = Omit<MutateProps<LogsArchive, APIErrorResponse, void, LogsArchiveCreateRequest, void>, "path" | "verb">;

/**
 * Create an archive
 * 
 * Create an archive in your organization.
 */
export const CreateLogsArchive = (props: CreateLogsArchiveProps) => (
  <Mutate<LogsArchive, APIErrorResponse, void, LogsArchiveCreateRequest, void>
    verb="POST"
    path={`/api/v2/logs/config/archives`}
    
    {...props}
  />
);

export type UseCreateLogsArchiveProps = Omit<UseMutateProps<LogsArchive, APIErrorResponse, void, LogsArchiveCreateRequest, void>, "path" | "verb">;

/**
 * Create an archive
 * 
 * Create an archive in your organization.
 */
export const useCreateLogsArchive = (props: UseCreateLogsArchiveProps) => useMutate<LogsArchive, APIErrorResponse, void, LogsArchiveCreateRequest, void>("POST", `/api/v2/logs/config/archives`, props);

export type CreateLogsArchivePromiseProps = Omit<LogsArchiveCreateRequest, "_authentication_token">;
/**
 * Create an archive
 * 
 * Create an archive in your organization.
 */
export const createLogsArchivePromise = (props: CreateLogsArchivePromiseProps) => HttpPOST<LogsArchive, CreateLogsArchivePromiseProps>('/api/v2/logs/config/archives')(props);


export type DeleteLogsArchiveProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an archive
 * 
 * Delete a given archive from your organization.
 */
export const DeleteLogsArchive = (props: DeleteLogsArchiveProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/logs/config/archives`}
    
    {...props}
  />
);

export type UseDeleteLogsArchiveProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an archive
 * 
 * Delete a given archive from your organization.
 */
export const useDeleteLogsArchive = (props: UseDeleteLogsArchiveProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v2/logs/config/archives`, {   ...props });


export interface GetLogsArchivePathParams {
  /**
   * The ID of the archive.
   */
  archive_id: string
}

export type GetLogsArchiveProps = Omit<GetProps<LogsArchive, APIErrorResponse, void, GetLogsArchivePathParams>, "path"> & GetLogsArchivePathParams;

/**
 * Get an archive
 * 
 * Get a specific archive from your organization.
 */
export const GetLogsArchive = ({archive_id, ...props}: GetLogsArchiveProps) => (
  <Get<LogsArchive, APIErrorResponse, void, GetLogsArchivePathParams>
    path={`/api/v2/logs/config/archives/${archive_id}`}
    
    {...props}
  />
);

export type UseGetLogsArchiveProps = Omit<UseGetProps<LogsArchive, APIErrorResponse, void, GetLogsArchivePathParams>, "path"> & GetLogsArchivePathParams;

/**
 * Get an archive
 * 
 * Get a specific archive from your organization.
 */
export const useGetLogsArchive = ({archive_id, ...props}: UseGetLogsArchiveProps) => useGet<LogsArchive, APIErrorResponse, void, GetLogsArchivePathParams>((paramsInPath: GetLogsArchivePathParams) => `/api/v2/logs/config/archives/${paramsInPath.archive_id}`, {  pathParams: { archive_id }, ...props });

/**
 * Get an archive
 * 
 * Get a specific archive from your organization.
 */
export const getLogsArchivePromise = (props: void) => HttpGET<LogsArchive, void>('/api/v2/logs/config/archives/${archive_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateLogsArchivePathParams {
  /**
   * The ID of the archive.
   */
  archive_id: string
}

export type UpdateLogsArchiveProps = Omit<MutateProps<LogsArchive, APIErrorResponse, void, LogsArchiveCreateRequest, UpdateLogsArchivePathParams>, "path" | "verb"> & UpdateLogsArchivePathParams;

/**
 * Update an archive
 * 
 * Update a given archive configuration.
 * 
 * **Note**: Using this method updates your archive configuration by **replacing**
 * your current configuration with the new one sent to your Datadog organization.
 */
export const UpdateLogsArchive = ({archive_id, ...props}: UpdateLogsArchiveProps) => (
  <Mutate<LogsArchive, APIErrorResponse, void, LogsArchiveCreateRequest, UpdateLogsArchivePathParams>
    verb="PUT"
    path={`/api/v2/logs/config/archives/${archive_id}`}
    
    {...props}
  />
);

export type UseUpdateLogsArchiveProps = Omit<UseMutateProps<LogsArchive, APIErrorResponse, void, LogsArchiveCreateRequest, UpdateLogsArchivePathParams>, "path" | "verb"> & UpdateLogsArchivePathParams;

/**
 * Update an archive
 * 
 * Update a given archive configuration.
 * 
 * **Note**: Using this method updates your archive configuration by **replacing**
 * your current configuration with the new one sent to your Datadog organization.
 */
export const useUpdateLogsArchive = ({archive_id, ...props}: UseUpdateLogsArchiveProps) => useMutate<LogsArchive, APIErrorResponse, void, LogsArchiveCreateRequest, UpdateLogsArchivePathParams>("PUT", (paramsInPath: UpdateLogsArchivePathParams) => `/api/v2/logs/config/archives/${paramsInPath.archive_id}`, {  pathParams: { archive_id }, ...props });


export interface RemoveRoleFromArchivePathParams {
  /**
   * The ID of the archive.
   */
  archive_id: string
}

export type RemoveRoleFromArchiveProps = Omit<MutateProps<void, APIErrorResponse, void, RelationshipToRole, RemoveRoleFromArchivePathParams>, "path" | "verb"> & RemoveRoleFromArchivePathParams;

/**
 * Revoke role from an archive
 * 
 * Removes a role from an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
 */
export const RemoveRoleFromArchive = ({archive_id, ...props}: RemoveRoleFromArchiveProps) => (
  <Mutate<void, APIErrorResponse, void, RelationshipToRole, RemoveRoleFromArchivePathParams>
    verb="DELETE"
    path={`/api/v2/logs/config/archives/${archive_id}/readers`}
    
    {...props}
  />
);

export type UseRemoveRoleFromArchiveProps = Omit<UseMutateProps<void, APIErrorResponse, void, RelationshipToRole, RemoveRoleFromArchivePathParams>, "path" | "verb"> & RemoveRoleFromArchivePathParams;

/**
 * Revoke role from an archive
 * 
 * Removes a role from an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
 */
export const useRemoveRoleFromArchive = ({archive_id, ...props}: UseRemoveRoleFromArchiveProps) => useMutate<void, APIErrorResponse, void, RelationshipToRole, RemoveRoleFromArchivePathParams>("DELETE", (paramsInPath: RemoveRoleFromArchivePathParams) => `/api/v2/logs/config/archives/${paramsInPath.archive_id}/readers`, {  pathParams: { archive_id }, ...props });


export interface ListArchiveReadRolesPathParams {
  /**
   * The ID of the archive.
   */
  archive_id: string
}

export type ListArchiveReadRolesProps = Omit<GetProps<RolesResponse, APIErrorResponse, void, ListArchiveReadRolesPathParams>, "path"> & ListArchiveReadRolesPathParams;

/**
 * List read roles for an archive
 * 
 * Returns all read roles a given archive is restricted to.
 */
export const ListArchiveReadRoles = ({archive_id, ...props}: ListArchiveReadRolesProps) => (
  <Get<RolesResponse, APIErrorResponse, void, ListArchiveReadRolesPathParams>
    path={`/api/v2/logs/config/archives/${archive_id}/readers`}
    
    {...props}
  />
);

export type UseListArchiveReadRolesProps = Omit<UseGetProps<RolesResponse, APIErrorResponse, void, ListArchiveReadRolesPathParams>, "path"> & ListArchiveReadRolesPathParams;

/**
 * List read roles for an archive
 * 
 * Returns all read roles a given archive is restricted to.
 */
export const useListArchiveReadRoles = ({archive_id, ...props}: UseListArchiveReadRolesProps) => useGet<RolesResponse, APIErrorResponse, void, ListArchiveReadRolesPathParams>((paramsInPath: ListArchiveReadRolesPathParams) => `/api/v2/logs/config/archives/${paramsInPath.archive_id}/readers`, {  pathParams: { archive_id }, ...props });

/**
 * List read roles for an archive
 * 
 * Returns all read roles a given archive is restricted to.
 */
export const listArchiveReadRolesPromise = (props: void) => HttpGET<RolesResponse, void>('/api/v2/logs/config/archives/${archive_id}/readers', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface AddReadRoleToArchivePathParams {
  /**
   * The ID of the archive.
   */
  archive_id: string
}

export type AddReadRoleToArchiveProps = Omit<MutateProps<void, APIErrorResponse, void, RelationshipToRole, AddReadRoleToArchivePathParams>, "path" | "verb"> & AddReadRoleToArchivePathParams;

/**
 * Grant role to an archive
 * 
 * Adds a read role to an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
 */
export const AddReadRoleToArchive = ({archive_id, ...props}: AddReadRoleToArchiveProps) => (
  <Mutate<void, APIErrorResponse, void, RelationshipToRole, AddReadRoleToArchivePathParams>
    verb="POST"
    path={`/api/v2/logs/config/archives/${archive_id}/readers`}
    
    {...props}
  />
);

export type UseAddReadRoleToArchiveProps = Omit<UseMutateProps<void, APIErrorResponse, void, RelationshipToRole, AddReadRoleToArchivePathParams>, "path" | "verb"> & AddReadRoleToArchivePathParams;

/**
 * Grant role to an archive
 * 
 * Adds a read role to an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
 */
export const useAddReadRoleToArchive = ({archive_id, ...props}: UseAddReadRoleToArchiveProps) => useMutate<void, APIErrorResponse, void, RelationshipToRole, AddReadRoleToArchivePathParams>("POST", (paramsInPath: AddReadRoleToArchivePathParams) => `/api/v2/logs/config/archives/${paramsInPath.archive_id}/readers`, {  pathParams: { archive_id }, ...props });

export type AddReadRoleToArchivePromiseProps = Omit<RelationshipToRole, "_authentication_token">;
/**
 * Grant role to an archive
 * 
 * Adds a read role to an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
 */
export const addReadRoleToArchivePromise = (props: AddReadRoleToArchivePromiseProps) => HttpPOST<void, AddReadRoleToArchivePromiseProps>('/api/v2/logs/config/archives/${archive_id}/readers')(props);


export type ListLogsMetricsProps = Omit<GetProps<LogsMetricsResponse, NotAuthorizedResponseResponse | TooManyRequestsResponseResponse, void, void>, "path">;

/**
 * Get all log-based metrics
 * 
 * Get the list of configured log-based metrics with their definitions.
 */
export const ListLogsMetrics = (props: ListLogsMetricsProps) => (
  <Get<LogsMetricsResponse, NotAuthorizedResponseResponse | TooManyRequestsResponseResponse, void, void>
    path={`/api/v2/logs/config/metrics`}
    
    {...props}
  />
);

export type UseListLogsMetricsProps = Omit<UseGetProps<LogsMetricsResponse, NotAuthorizedResponseResponse | TooManyRequestsResponseResponse, void, void>, "path">;

/**
 * Get all log-based metrics
 * 
 * Get the list of configured log-based metrics with their definitions.
 */
export const useListLogsMetrics = (props: UseListLogsMetricsProps) => useGet<LogsMetricsResponse, NotAuthorizedResponseResponse | TooManyRequestsResponseResponse, void, void>(`/api/v2/logs/config/metrics`, props);

/**
 * Get all log-based metrics
 * 
 * Get the list of configured log-based metrics with their definitions.
 */
export const listLogsMetricsPromise = (props: void) => HttpGET<LogsMetricsResponse, void>('/api/v2/logs/config/metrics', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateLogsMetricProps = Omit<MutateProps<LogsMetricResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | ConflictResponseResponse | TooManyRequestsResponseResponse, void, LogsMetricCreateRequest, void>, "path" | "verb">;

/**
 * Create a log-based metric
 * 
 * Create a metric based on your ingested logs in your organization.
 * Returns the log-based metric object from the request body when the request is successful.
 */
export const CreateLogsMetric = (props: CreateLogsMetricProps) => (
  <Mutate<LogsMetricResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | ConflictResponseResponse | TooManyRequestsResponseResponse, void, LogsMetricCreateRequest, void>
    verb="POST"
    path={`/api/v2/logs/config/metrics`}
    
    {...props}
  />
);

export type UseCreateLogsMetricProps = Omit<UseMutateProps<LogsMetricResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | ConflictResponseResponse | TooManyRequestsResponseResponse, void, LogsMetricCreateRequest, void>, "path" | "verb">;

/**
 * Create a log-based metric
 * 
 * Create a metric based on your ingested logs in your organization.
 * Returns the log-based metric object from the request body when the request is successful.
 */
export const useCreateLogsMetric = (props: UseCreateLogsMetricProps) => useMutate<LogsMetricResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | ConflictResponseResponse | TooManyRequestsResponseResponse, void, LogsMetricCreateRequest, void>("POST", `/api/v2/logs/config/metrics`, props);

export type CreateLogsMetricPromiseProps = Omit<LogsMetricCreateRequest, "_authentication_token">;
/**
 * Create a log-based metric
 * 
 * Create a metric based on your ingested logs in your organization.
 * Returns the log-based metric object from the request body when the request is successful.
 */
export const createLogsMetricPromise = (props: CreateLogsMetricPromiseProps) => HttpPOST<LogsMetricResponse, CreateLogsMetricPromiseProps>('/api/v2/logs/config/metrics')(props);


export type DeleteLogsMetricProps = Omit<MutateProps<void, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a log-based metric
 * 
 * Delete a specific log-based metric from your organization.
 */
export const DeleteLogsMetric = (props: DeleteLogsMetricProps) => (
  <Mutate<void, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/logs/config/metrics`}
    
    {...props}
  />
);

export type UseDeleteLogsMetricProps = Omit<UseMutateProps<void, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a log-based metric
 * 
 * Delete a specific log-based metric from your organization.
 */
export const useDeleteLogsMetric = (props: UseDeleteLogsMetricProps) => useMutate<void, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, string, void>("DELETE", `/api/v2/logs/config/metrics`, {   ...props });


export interface GetLogsMetricPathParams {
  /**
   * The name of the log-based metric.
   */
  metric_id: string
}

export type GetLogsMetricProps = Omit<GetProps<LogsMetricResponse, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, GetLogsMetricPathParams>, "path"> & GetLogsMetricPathParams;

/**
 * Get a log-based metric
 * 
 * Get a specific log-based metric from your organization.
 */
export const GetLogsMetric = ({metric_id, ...props}: GetLogsMetricProps) => (
  <Get<LogsMetricResponse, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, GetLogsMetricPathParams>
    path={`/api/v2/logs/config/metrics/${metric_id}`}
    
    {...props}
  />
);

export type UseGetLogsMetricProps = Omit<UseGetProps<LogsMetricResponse, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, GetLogsMetricPathParams>, "path"> & GetLogsMetricPathParams;

/**
 * Get a log-based metric
 * 
 * Get a specific log-based metric from your organization.
 */
export const useGetLogsMetric = ({metric_id, ...props}: UseGetLogsMetricProps) => useGet<LogsMetricResponse, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, GetLogsMetricPathParams>((paramsInPath: GetLogsMetricPathParams) => `/api/v2/logs/config/metrics/${paramsInPath.metric_id}`, {  pathParams: { metric_id }, ...props });

/**
 * Get a log-based metric
 * 
 * Get a specific log-based metric from your organization.
 */
export const getLogsMetricPromise = (props: void) => HttpGET<LogsMetricResponse, void>('/api/v2/logs/config/metrics/${metric_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateLogsMetricPathParams {
  /**
   * The name of the log-based metric.
   */
  metric_id: string
}

export type UpdateLogsMetricProps = Omit<MutateProps<LogsMetricResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, LogsMetricUpdateRequest, UpdateLogsMetricPathParams>, "path" | "verb"> & UpdateLogsMetricPathParams;

/**
 * Update a log-based metric
 * 
 * Update a specific log-based metric from your organization.
 * Returns the log-based metric object from the request body when the request is successful.
 */
export const UpdateLogsMetric = ({metric_id, ...props}: UpdateLogsMetricProps) => (
  <Mutate<LogsMetricResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, LogsMetricUpdateRequest, UpdateLogsMetricPathParams>
    verb="PATCH"
    path={`/api/v2/logs/config/metrics/${metric_id}`}
    
    {...props}
  />
);

export type UseUpdateLogsMetricProps = Omit<UseMutateProps<LogsMetricResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, LogsMetricUpdateRequest, UpdateLogsMetricPathParams>, "path" | "verb"> & UpdateLogsMetricPathParams;

/**
 * Update a log-based metric
 * 
 * Update a specific log-based metric from your organization.
 * Returns the log-based metric object from the request body when the request is successful.
 */
export const useUpdateLogsMetric = ({metric_id, ...props}: UseUpdateLogsMetricProps) => useMutate<LogsMetricResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, LogsMetricUpdateRequest, UpdateLogsMetricPathParams>("PATCH", (paramsInPath: UpdateLogsMetricPathParams) => `/api/v2/logs/config/metrics/${paramsInPath.metric_id}`, {  pathParams: { metric_id }, ...props });


export interface ListLogsGetQueryParams {
  /**
   * Search query following logs syntax.
   */
  "filter[query]"?: string;
  /**
   * For customers with multiple indexes, the indexes to search
   * Defaults to '*' which means all indexes
   */
  "filter[index]"?: string;
  /**
   * Minimum timestamp for requested logs.
   */
  "filter[from]"?: string;
  /**
   * Maximum timestamp for requested logs.
   */
  "filter[to]"?: string;
  /**
   * Order of logs in results.
   */
  sort?: LogsSort;
  /**
   * List following results with a cursor provided in the previous query.
   */
  "page[cursor]"?: string;
  /**
   * Maximum number of logs in the response.
   */
  "page[limit]"?: number;
}

export type ListLogsGetProps = Omit<GetProps<LogsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, ListLogsGetQueryParams, void>, "path">;

/**
 * Get a list of logs
 * 
 * List endpoint returns logs that match a log search query.
 * [Results are paginated][1].
 * 
 * Use this endpoint to see your latest logs.
 * 
 * **If you are considering archiving logs for your organization,
 * consider use of the Datadog archive capabilities instead of the log list API.
 * See [Datadog Logs Archive documentation][2].**
 * 
 * [1]: /logs/guide/collect-multiple-logs-with-pagination
 * [2]: https://docs.datadoghq.com/logs/archives
 */
export const ListLogsGet = (props: ListLogsGetProps) => (
  <Get<LogsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, ListLogsGetQueryParams, void>
    path={`/api/v2/logs/events`}
    
    {...props}
  />
);

export type UseListLogsGetProps = Omit<UseGetProps<LogsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, ListLogsGetQueryParams, void>, "path">;

/**
 * Get a list of logs
 * 
 * List endpoint returns logs that match a log search query.
 * [Results are paginated][1].
 * 
 * Use this endpoint to see your latest logs.
 * 
 * **If you are considering archiving logs for your organization,
 * consider use of the Datadog archive capabilities instead of the log list API.
 * See [Datadog Logs Archive documentation][2].**
 * 
 * [1]: /logs/guide/collect-multiple-logs-with-pagination
 * [2]: https://docs.datadoghq.com/logs/archives
 */
export const useListLogsGet = (props: UseListLogsGetProps) => useGet<LogsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, ListLogsGetQueryParams, void>(`/api/v2/logs/events`, props);

/**
 * Get a list of logs
 * 
 * List endpoint returns logs that match a log search query.
 * [Results are paginated][1].
 * 
 * Use this endpoint to see your latest logs.
 * 
 * **If you are considering archiving logs for your organization,
 * consider use of the Datadog archive capabilities instead of the log list API.
 * See [Datadog Logs Archive documentation][2].**
 * 
 * [1]: /logs/guide/collect-multiple-logs-with-pagination
 * [2]: https://docs.datadoghq.com/logs/archives
 */
export const listLogsGetPromise = (props: ListLogsGetQueryParams) => HttpGET<LogsListResponse, ListLogsGetQueryParams>('/api/v2/logs/events', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type ListLogsProps = Omit<MutateProps<LogsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, LogsListRequest, void>, "path" | "verb">;

/**
 * Search logs
 * 
 * List endpoint returns logs that match a log search query.
 * [Results are paginated][1].
 * 
 * Use this endpoint to build complex logs filtering and search.
 * 
 * **If you are considering archiving logs for your organization,
 * consider use of the Datadog archive capabilities instead of the log list API.
 * See [Datadog Logs Archive documentation][2].**
 * 
 * [1]: /logs/guide/collect-multiple-logs-with-pagination
 * [2]: https://docs.datadoghq.com/logs/archives
 */
export const ListLogs = (props: ListLogsProps) => (
  <Mutate<LogsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, LogsListRequest, void>
    verb="POST"
    path={`/api/v2/logs/events/search`}
    
    {...props}
  />
);

export type UseListLogsProps = Omit<UseMutateProps<LogsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, LogsListRequest, void>, "path" | "verb">;

/**
 * Search logs
 * 
 * List endpoint returns logs that match a log search query.
 * [Results are paginated][1].
 * 
 * Use this endpoint to build complex logs filtering and search.
 * 
 * **If you are considering archiving logs for your organization,
 * consider use of the Datadog archive capabilities instead of the log list API.
 * See [Datadog Logs Archive documentation][2].**
 * 
 * [1]: /logs/guide/collect-multiple-logs-with-pagination
 * [2]: https://docs.datadoghq.com/logs/archives
 */
export const useListLogs = (props: UseListLogsProps) => useMutate<LogsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, LogsListRequest, void>("POST", `/api/v2/logs/events/search`, props);

export type ListLogsPromiseProps = Omit<LogsListRequest, "_authentication_token">;
/**
 * Search logs
 * 
 * List endpoint returns logs that match a log search query.
 * [Results are paginated][1].
 * 
 * Use this endpoint to build complex logs filtering and search.
 * 
 * **If you are considering archiving logs for your organization,
 * consider use of the Datadog archive capabilities instead of the log list API.
 * See [Datadog Logs Archive documentation][2].**
 * 
 * [1]: /logs/guide/collect-multiple-logs-with-pagination
 * [2]: https://docs.datadoghq.com/logs/archives
 */
export const listLogsPromise = (props: ListLogsPromiseProps) => HttpPOST<LogsListResponse, ListLogsPromiseProps>('/api/v2/logs/events/search')(props);


export interface ListTagConfigurationsQueryParams {
  /**
   * Filter metrics that have configured tags.
   */
  "filter[configured]"?: boolean;
  /**
   * Filter tag configurations by configured tags.
   */
  "filter[tags_configured]"?: string;
  /**
   * Filter tag configurations by metric type.
   */
  "filter[metric_type]"?: MetricTagConfigurationMetricTypes;
  /**
   * Filter distributions with additional percentile
   * aggregations enabled or disabled.
   */
  "filter[include_percentiles]"?: boolean;
  /**
   * Filter metrics that have been submitted with the given tags. Supports boolean and wildcard expressions.
   * Cannot be combined with other filters.
   */
  "filter[tags]"?: string;
  /**
   * The number of seconds of look back (from now) to apply to a filter[tag] query.
   * Defaults value is 3600 (1 hour), maximum value is 172,800 (2 days).
   */
  "window[seconds]"?: number;
}

export type ListTagConfigurationsProps = Omit<GetProps<MetricsAndMetricTagConfigurationsResponse, APIErrorResponse, ListTagConfigurationsQueryParams, void>, "path">;

/**
 * List tag configurations
 * 
 * Returns all configured count/gauge/rate/distribution metric names
 * (with additional filters if specified).
 */
export const ListTagConfigurations = (props: ListTagConfigurationsProps) => (
  <Get<MetricsAndMetricTagConfigurationsResponse, APIErrorResponse, ListTagConfigurationsQueryParams, void>
    path={`/api/v2/metrics`}
    
    {...props}
  />
);

export type UseListTagConfigurationsProps = Omit<UseGetProps<MetricsAndMetricTagConfigurationsResponse, APIErrorResponse, ListTagConfigurationsQueryParams, void>, "path">;

/**
 * List tag configurations
 * 
 * Returns all configured count/gauge/rate/distribution metric names
 * (with additional filters if specified).
 */
export const useListTagConfigurations = (props: UseListTagConfigurationsProps) => useGet<MetricsAndMetricTagConfigurationsResponse, APIErrorResponse, ListTagConfigurationsQueryParams, void>(`/api/v2/metrics`, props);

/**
 * List tag configurations
 * 
 * Returns all configured count/gauge/rate/distribution metric names
 * (with additional filters if specified).
 */
export const listTagConfigurationsPromise = (props: ListTagConfigurationsQueryParams) => HttpGET<MetricsAndMetricTagConfigurationsResponse, ListTagConfigurationsQueryParams>('/api/v2/metrics', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface ListTagsByMetricNamePathParams {
  /**
   * The name of the metric.
   */
  metric_name: string
}

export type ListTagsByMetricNameProps = Omit<GetProps<MetricAllTagsResponse, APIErrorResponse, void, ListTagsByMetricNamePathParams>, "path"> & ListTagsByMetricNamePathParams;

/**
 * List tags by metric name
 * 
 * View indexed tag key-value pairs for a given metric name.
 */
export const ListTagsByMetricName = ({metric_name, ...props}: ListTagsByMetricNameProps) => (
  <Get<MetricAllTagsResponse, APIErrorResponse, void, ListTagsByMetricNamePathParams>
    path={`/api/v2/metrics/${metric_name}/all-tags`}
    
    {...props}
  />
);

export type UseListTagsByMetricNameProps = Omit<UseGetProps<MetricAllTagsResponse, APIErrorResponse, void, ListTagsByMetricNamePathParams>, "path"> & ListTagsByMetricNamePathParams;

/**
 * List tags by metric name
 * 
 * View indexed tag key-value pairs for a given metric name.
 */
export const useListTagsByMetricName = ({metric_name, ...props}: UseListTagsByMetricNameProps) => useGet<MetricAllTagsResponse, APIErrorResponse, void, ListTagsByMetricNamePathParams>((paramsInPath: ListTagsByMetricNamePathParams) => `/api/v2/metrics/${paramsInPath.metric_name}/all-tags`, {  pathParams: { metric_name }, ...props });

/**
 * List tags by metric name
 * 
 * View indexed tag key-value pairs for a given metric name.
 */
export const listTagsByMetricNamePromise = (props: void) => HttpGET<MetricAllTagsResponse, void>('/api/v2/metrics/${metric_name}/all-tags', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface DeleteTagConfigurationPathParams {
  /**
   * The name of the metric.
   */
  metric_name: string
}

export type DeleteTagConfigurationProps = Omit<MutateProps<void, APIErrorResponse, void, void, DeleteTagConfigurationPathParams>, "path" | "verb"> & DeleteTagConfigurationPathParams;

/**
 * Delete a tag configuration
 * 
 * Deletes a metric's tag configuration. Can only be used with application
 * keys from users with the `Manage Tags for Metrics` permission.
 */
export const DeleteTagConfiguration = ({metric_name, ...props}: DeleteTagConfigurationProps) => (
  <Mutate<void, APIErrorResponse, void, void, DeleteTagConfigurationPathParams>
    verb="DELETE"
    path={`/api/v2/metrics/${metric_name}/tags`}
    
    {...props}
  />
);

export type UseDeleteTagConfigurationProps = Omit<UseMutateProps<void, APIErrorResponse, void, void, DeleteTagConfigurationPathParams>, "path" | "verb"> & DeleteTagConfigurationPathParams;

/**
 * Delete a tag configuration
 * 
 * Deletes a metric's tag configuration. Can only be used with application
 * keys from users with the `Manage Tags for Metrics` permission.
 */
export const useDeleteTagConfiguration = ({metric_name, ...props}: UseDeleteTagConfigurationProps) => useMutate<void, APIErrorResponse, void, void, DeleteTagConfigurationPathParams>("DELETE", (paramsInPath: DeleteTagConfigurationPathParams) => `/api/v2/metrics/${paramsInPath.metric_name}/tags`, {  pathParams: { metric_name }, ...props });


export interface ListTagConfigurationByNamePathParams {
  /**
   * The name of the metric.
   */
  metric_name: string
}

export type ListTagConfigurationByNameProps = Omit<GetProps<MetricTagConfigurationResponse, APIErrorResponse, void, ListTagConfigurationByNamePathParams>, "path"> & ListTagConfigurationByNamePathParams;

/**
 * List tag configuration by name
 * 
 * Returns the tag configuration for the given metric name.
 */
export const ListTagConfigurationByName = ({metric_name, ...props}: ListTagConfigurationByNameProps) => (
  <Get<MetricTagConfigurationResponse, APIErrorResponse, void, ListTagConfigurationByNamePathParams>
    path={`/api/v2/metrics/${metric_name}/tags`}
    
    {...props}
  />
);

export type UseListTagConfigurationByNameProps = Omit<UseGetProps<MetricTagConfigurationResponse, APIErrorResponse, void, ListTagConfigurationByNamePathParams>, "path"> & ListTagConfigurationByNamePathParams;

/**
 * List tag configuration by name
 * 
 * Returns the tag configuration for the given metric name.
 */
export const useListTagConfigurationByName = ({metric_name, ...props}: UseListTagConfigurationByNameProps) => useGet<MetricTagConfigurationResponse, APIErrorResponse, void, ListTagConfigurationByNamePathParams>((paramsInPath: ListTagConfigurationByNamePathParams) => `/api/v2/metrics/${paramsInPath.metric_name}/tags`, {  pathParams: { metric_name }, ...props });

/**
 * List tag configuration by name
 * 
 * Returns the tag configuration for the given metric name.
 */
export const listTagConfigurationByNamePromise = (props: void) => HttpGET<MetricTagConfigurationResponse, void>('/api/v2/metrics/${metric_name}/tags', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateTagConfigurationPathParams {
  /**
   * The name of the metric.
   */
  metric_name: string
}

export type UpdateTagConfigurationProps = Omit<MutateProps<MetricTagConfigurationResponse, APIErrorResponse, void, MetricTagConfigurationUpdateRequest, UpdateTagConfigurationPathParams>, "path" | "verb"> & UpdateTagConfigurationPathParams;

/**
 * Update a tag configuration
 * 
 * Update the tag configuration of a metric or percentile aggregations of a distribution metric or custom aggregations
 * of a count, rate, or gauge metric.
 * Can only be used with application keys from users with the `Manage Tags for Metrics` permission.
 */
export const UpdateTagConfiguration = ({metric_name, ...props}: UpdateTagConfigurationProps) => (
  <Mutate<MetricTagConfigurationResponse, APIErrorResponse, void, MetricTagConfigurationUpdateRequest, UpdateTagConfigurationPathParams>
    verb="PATCH"
    path={`/api/v2/metrics/${metric_name}/tags`}
    
    {...props}
  />
);

export type UseUpdateTagConfigurationProps = Omit<UseMutateProps<MetricTagConfigurationResponse, APIErrorResponse, void, MetricTagConfigurationUpdateRequest, UpdateTagConfigurationPathParams>, "path" | "verb"> & UpdateTagConfigurationPathParams;

/**
 * Update a tag configuration
 * 
 * Update the tag configuration of a metric or percentile aggregations of a distribution metric or custom aggregations
 * of a count, rate, or gauge metric.
 * Can only be used with application keys from users with the `Manage Tags for Metrics` permission.
 */
export const useUpdateTagConfiguration = ({metric_name, ...props}: UseUpdateTagConfigurationProps) => useMutate<MetricTagConfigurationResponse, APIErrorResponse, void, MetricTagConfigurationUpdateRequest, UpdateTagConfigurationPathParams>("PATCH", (paramsInPath: UpdateTagConfigurationPathParams) => `/api/v2/metrics/${paramsInPath.metric_name}/tags`, {  pathParams: { metric_name }, ...props });


export interface CreateTagConfigurationPathParams {
  /**
   * The name of the metric.
   */
  metric_name: string
}

export type CreateTagConfigurationProps = Omit<MutateProps<MetricTagConfigurationResponse, APIErrorResponse, void, MetricTagConfigurationCreateRequest, CreateTagConfigurationPathParams>, "path" | "verb"> & CreateTagConfigurationPathParams;

/**
 * Create a tag configuration
 * 
 * Create and define a list of queryable tag keys for an existing count/gauge/rate/distribution metric.
 * Optionally, include percentile aggregations on any distribution metric or configure custom aggregations
 * on any count, rate, or gauge metric.
 * Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
 */
export const CreateTagConfiguration = ({metric_name, ...props}: CreateTagConfigurationProps) => (
  <Mutate<MetricTagConfigurationResponse, APIErrorResponse, void, MetricTagConfigurationCreateRequest, CreateTagConfigurationPathParams>
    verb="POST"
    path={`/api/v2/metrics/${metric_name}/tags`}
    
    {...props}
  />
);

export type UseCreateTagConfigurationProps = Omit<UseMutateProps<MetricTagConfigurationResponse, APIErrorResponse, void, MetricTagConfigurationCreateRequest, CreateTagConfigurationPathParams>, "path" | "verb"> & CreateTagConfigurationPathParams;

/**
 * Create a tag configuration
 * 
 * Create and define a list of queryable tag keys for an existing count/gauge/rate/distribution metric.
 * Optionally, include percentile aggregations on any distribution metric or configure custom aggregations
 * on any count, rate, or gauge metric.
 * Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
 */
export const useCreateTagConfiguration = ({metric_name, ...props}: UseCreateTagConfigurationProps) => useMutate<MetricTagConfigurationResponse, APIErrorResponse, void, MetricTagConfigurationCreateRequest, CreateTagConfigurationPathParams>("POST", (paramsInPath: CreateTagConfigurationPathParams) => `/api/v2/metrics/${paramsInPath.metric_name}/tags`, {  pathParams: { metric_name }, ...props });

export type CreateTagConfigurationPromiseProps = Omit<MetricTagConfigurationCreateRequest, "_authentication_token">;
/**
 * Create a tag configuration
 * 
 * Create and define a list of queryable tag keys for an existing count/gauge/rate/distribution metric.
 * Optionally, include percentile aggregations on any distribution metric or configure custom aggregations
 * on any count, rate, or gauge metric.
 * Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
 */
export const createTagConfigurationPromise = (props: CreateTagConfigurationPromiseProps) => HttpPOST<MetricTagConfigurationResponse, CreateTagConfigurationPromiseProps>('/api/v2/metrics/${metric_name}/tags')(props);


export interface ListVolumesByMetricNamePathParams {
  /**
   * The name of the metric.
   */
  metric_name: string
}

export type ListVolumesByMetricNameProps = Omit<GetProps<MetricVolumesResponse, APIErrorResponse, void, ListVolumesByMetricNamePathParams>, "path"> & ListVolumesByMetricNamePathParams;

/**
 * List distinct metric volumes by metric name
 * 
 * View distinct metrics volumes for the given metric name.
 * 
 * Custom distribution metrics will return both ingested and indexed custom metric volumes.
 * For Metrics without Limits&trade; beta customers, all metrics will return both ingested/indexed volumes.
 * Custom metrics generated in-app from other products will return `null` for ingested volumes.
 */
export const ListVolumesByMetricName = ({metric_name, ...props}: ListVolumesByMetricNameProps) => (
  <Get<MetricVolumesResponse, APIErrorResponse, void, ListVolumesByMetricNamePathParams>
    path={`/api/v2/metrics/${metric_name}/volumes`}
    
    {...props}
  />
);

export type UseListVolumesByMetricNameProps = Omit<UseGetProps<MetricVolumesResponse, APIErrorResponse, void, ListVolumesByMetricNamePathParams>, "path"> & ListVolumesByMetricNamePathParams;

/**
 * List distinct metric volumes by metric name
 * 
 * View distinct metrics volumes for the given metric name.
 * 
 * Custom distribution metrics will return both ingested and indexed custom metric volumes.
 * For Metrics without Limits&trade; beta customers, all metrics will return both ingested/indexed volumes.
 * Custom metrics generated in-app from other products will return `null` for ingested volumes.
 */
export const useListVolumesByMetricName = ({metric_name, ...props}: UseListVolumesByMetricNameProps) => useGet<MetricVolumesResponse, APIErrorResponse, void, ListVolumesByMetricNamePathParams>((paramsInPath: ListVolumesByMetricNamePathParams) => `/api/v2/metrics/${paramsInPath.metric_name}/volumes`, {  pathParams: { metric_name }, ...props });

/**
 * List distinct metric volumes by metric name
 * 
 * View distinct metrics volumes for the given metric name.
 * 
 * Custom distribution metrics will return both ingested and indexed custom metric volumes.
 * For Metrics without Limits&trade; beta customers, all metrics will return both ingested/indexed volumes.
 * Custom metrics generated in-app from other products will return `null` for ingested volumes.
 */
export const listVolumesByMetricNamePromise = (props: void) => HttpGET<MetricVolumesResponse, void>('/api/v2/metrics/${metric_name}/volumes', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type ListPermissionsProps = Omit<GetProps<PermissionsResponse, APIErrorResponse, void, void>, "path">;

/**
 * List permissions
 * 
 * Returns a list of all permissions, including name, description, and ID.
 */
export const ListPermissions = (props: ListPermissionsProps) => (
  <Get<PermissionsResponse, APIErrorResponse, void, void>
    path={`/api/v2/permissions`}
    
    {...props}
  />
);

export type UseListPermissionsProps = Omit<UseGetProps<PermissionsResponse, APIErrorResponse, void, void>, "path">;

/**
 * List permissions
 * 
 * Returns a list of all permissions, including name, description, and ID.
 */
export const useListPermissions = (props: UseListPermissionsProps) => useGet<PermissionsResponse, APIErrorResponse, void, void>(`/api/v2/permissions`, props);

/**
 * List permissions
 * 
 * Returns a list of all permissions, including name, description, and ID.
 */
export const listPermissionsPromise = (props: void) => HttpGET<PermissionsResponse, void>('/api/v2/permissions', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface ListProcessesQueryParams {
  /**
   * String to search processes by.
   */
  search?: string;
  /**
   * Comma-separated list of tags to filter processes by.
   */
  tags?: string;
  /**
   * Unix timestamp (number of seconds since epoch) of the start of the query window.
   * If not provided, the start of the query window will be 15 minutes before the `to` timestamp. If neither
   * `from` nor `to` are provided, the query window will be `[now - 15m, now]`.
   */
  from?: number;
  /**
   * Unix timestamp (number of seconds since epoch) of the end of the query window.
   * If not provided, the end of the query window will be 15 minutes after the `from` timestamp. If neither
   * `from` nor `to` are provided, the query window will be `[now - 15m, now]`.
   */
  to?: number;
  /**
   * Maximum number of results returned.
   */
  "page[limit]"?: number;
  /**
   * String to query the next page of results.
   * This key is provided with each valid response from the API in `meta.page.after`.
   */
  "page[cursor]"?: string;
}

export type ListProcessesProps = Omit<GetProps<ProcessSummariesResponse, APIErrorResponse, ListProcessesQueryParams, void>, "path">;

/**
 * Get all processes
 * 
 * Get all processes for your organization.
 */
export const ListProcesses = (props: ListProcessesProps) => (
  <Get<ProcessSummariesResponse, APIErrorResponse, ListProcessesQueryParams, void>
    path={`/api/v2/processes`}
    
    {...props}
  />
);

export type UseListProcessesProps = Omit<UseGetProps<ProcessSummariesResponse, APIErrorResponse, ListProcessesQueryParams, void>, "path">;

/**
 * Get all processes
 * 
 * Get all processes for your organization.
 */
export const useListProcesses = (props: UseListProcessesProps) => useGet<ProcessSummariesResponse, APIErrorResponse, ListProcessesQueryParams, void>(`/api/v2/processes`, props);

/**
 * Get all processes
 * 
 * Get all processes for your organization.
 */
export const listProcessesPromise = (props: ListProcessesQueryParams) => HttpGET<ProcessSummariesResponse, ListProcessesQueryParams>('/api/v2/processes', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface ListRolesQueryParams {
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific page number to return.
   */
  "page[number]"?: number;
  /**
   * Sort roles depending on the given field. Sort order is **ascending** by default.
   * Sort order is **descending** if the field is prefixed by a negative sign, for example:
   * `sort=-name`.
   */
  sort?: RolesSort;
  /**
   * Filter all roles by the given string.
   */
  filter?: string;
}

export type ListRolesProps = Omit<GetProps<RolesResponse, APIErrorResponse, ListRolesQueryParams, void>, "path">;

/**
 * List roles
 * 
 * Returns all roles, including their names and IDs.
 */
export const ListRoles = (props: ListRolesProps) => (
  <Get<RolesResponse, APIErrorResponse, ListRolesQueryParams, void>
    path={`/api/v2/roles`}
    
    {...props}
  />
);

export type UseListRolesProps = Omit<UseGetProps<RolesResponse, APIErrorResponse, ListRolesQueryParams, void>, "path">;

/**
 * List roles
 * 
 * Returns all roles, including their names and IDs.
 */
export const useListRoles = (props: UseListRolesProps) => useGet<RolesResponse, APIErrorResponse, ListRolesQueryParams, void>(`/api/v2/roles`, props);

/**
 * List roles
 * 
 * Returns all roles, including their names and IDs.
 */
export const listRolesPromise = (props: ListRolesQueryParams) => HttpGET<RolesResponse, ListRolesQueryParams>('/api/v2/roles', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateRoleProps = Omit<MutateProps<RoleCreateResponse, APIErrorResponse, void, RoleCreateRequest, void>, "path" | "verb">;

/**
 * Create role
 * 
 * Create a new role for your organization.
 */
export const CreateRole = (props: CreateRoleProps) => (
  <Mutate<RoleCreateResponse, APIErrorResponse, void, RoleCreateRequest, void>
    verb="POST"
    path={`/api/v2/roles`}
    
    {...props}
  />
);

export type UseCreateRoleProps = Omit<UseMutateProps<RoleCreateResponse, APIErrorResponse, void, RoleCreateRequest, void>, "path" | "verb">;

/**
 * Create role
 * 
 * Create a new role for your organization.
 */
export const useCreateRole = (props: UseCreateRoleProps) => useMutate<RoleCreateResponse, APIErrorResponse, void, RoleCreateRequest, void>("POST", `/api/v2/roles`, props);

export type CreateRolePromiseProps = Omit<RoleCreateRequest, "_authentication_token">;
/**
 * Create role
 * 
 * Create a new role for your organization.
 */
export const createRolePromise = (props: CreateRolePromiseProps) => HttpPOST<RoleCreateResponse, CreateRolePromiseProps>('/api/v2/roles')(props);


export type DeleteRoleProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete role
 * 
 * Disables a role.
 */
export const DeleteRole = (props: DeleteRoleProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/roles`}
    
    {...props}
  />
);

export type UseDeleteRoleProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Delete role
 * 
 * Disables a role.
 */
export const useDeleteRole = (props: UseDeleteRoleProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v2/roles`, {   ...props });


export interface GetRolePathParams {
  /**
   * The ID of the role.
   */
  role_id: string
}

export type GetRoleProps = Omit<GetProps<RoleResponse, APIErrorResponse, void, GetRolePathParams>, "path"> & GetRolePathParams;

/**
 * Get a role
 * 
 * Get a role in the organization specified by the roles `role_id`.
 */
export const GetRole = ({role_id, ...props}: GetRoleProps) => (
  <Get<RoleResponse, APIErrorResponse, void, GetRolePathParams>
    path={`/api/v2/roles/${role_id}`}
    
    {...props}
  />
);

export type UseGetRoleProps = Omit<UseGetProps<RoleResponse, APIErrorResponse, void, GetRolePathParams>, "path"> & GetRolePathParams;

/**
 * Get a role
 * 
 * Get a role in the organization specified by the roles `role_id`.
 */
export const useGetRole = ({role_id, ...props}: UseGetRoleProps) => useGet<RoleResponse, APIErrorResponse, void, GetRolePathParams>((paramsInPath: GetRolePathParams) => `/api/v2/roles/${paramsInPath.role_id}`, {  pathParams: { role_id }, ...props });

/**
 * Get a role
 * 
 * Get a role in the organization specified by the roles `role_id`.
 */
export const getRolePromise = (props: void) => HttpGET<RoleResponse, void>('/api/v2/roles/${role_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateRolePathParams {
  /**
   * The ID of the role.
   */
  role_id: string
}

export type UpdateRoleProps = Omit<MutateProps<RoleUpdateResponse, APIErrorResponse, void, RoleUpdateRequest, UpdateRolePathParams>, "path" | "verb"> & UpdateRolePathParams;

/**
 * Update a role
 * 
 * Edit a role. Can only be used with application keys belonging to administrators.
 */
export const UpdateRole = ({role_id, ...props}: UpdateRoleProps) => (
  <Mutate<RoleUpdateResponse, APIErrorResponse, void, RoleUpdateRequest, UpdateRolePathParams>
    verb="PATCH"
    path={`/api/v2/roles/${role_id}`}
    
    {...props}
  />
);

export type UseUpdateRoleProps = Omit<UseMutateProps<RoleUpdateResponse, APIErrorResponse, void, RoleUpdateRequest, UpdateRolePathParams>, "path" | "verb"> & UpdateRolePathParams;

/**
 * Update a role
 * 
 * Edit a role. Can only be used with application keys belonging to administrators.
 */
export const useUpdateRole = ({role_id, ...props}: UseUpdateRoleProps) => useMutate<RoleUpdateResponse, APIErrorResponse, void, RoleUpdateRequest, UpdateRolePathParams>("PATCH", (paramsInPath: UpdateRolePathParams) => `/api/v2/roles/${paramsInPath.role_id}`, {  pathParams: { role_id }, ...props });


export interface RemovePermissionFromRolePathParams {
  /**
   * The ID of the role.
   */
  role_id: string
}

export type RemovePermissionFromRoleProps = Omit<MutateProps<PermissionsResponse, APIErrorResponse, void, RelationshipToPermission, RemovePermissionFromRolePathParams>, "path" | "verb"> & RemovePermissionFromRolePathParams;

/**
 * Revoke permission
 * 
 * Removes a permission from a role.
 */
export const RemovePermissionFromRole = ({role_id, ...props}: RemovePermissionFromRoleProps) => (
  <Mutate<PermissionsResponse, APIErrorResponse, void, RelationshipToPermission, RemovePermissionFromRolePathParams>
    verb="DELETE"
    path={`/api/v2/roles/${role_id}/permissions`}
    
    {...props}
  />
);

export type UseRemovePermissionFromRoleProps = Omit<UseMutateProps<PermissionsResponse, APIErrorResponse, void, RelationshipToPermission, RemovePermissionFromRolePathParams>, "path" | "verb"> & RemovePermissionFromRolePathParams;

/**
 * Revoke permission
 * 
 * Removes a permission from a role.
 */
export const useRemovePermissionFromRole = ({role_id, ...props}: UseRemovePermissionFromRoleProps) => useMutate<PermissionsResponse, APIErrorResponse, void, RelationshipToPermission, RemovePermissionFromRolePathParams>("DELETE", (paramsInPath: RemovePermissionFromRolePathParams) => `/api/v2/roles/${paramsInPath.role_id}/permissions`, {  pathParams: { role_id }, ...props });


export interface ListRolePermissionsPathParams {
  /**
   * The ID of the role.
   */
  role_id: string
}

export type ListRolePermissionsProps = Omit<GetProps<PermissionsResponse, APIErrorResponse, void, ListRolePermissionsPathParams>, "path"> & ListRolePermissionsPathParams;

/**
 * List permissions for a role
 * 
 * Returns a list of all permissions for a single role.
 */
export const ListRolePermissions = ({role_id, ...props}: ListRolePermissionsProps) => (
  <Get<PermissionsResponse, APIErrorResponse, void, ListRolePermissionsPathParams>
    path={`/api/v2/roles/${role_id}/permissions`}
    
    {...props}
  />
);

export type UseListRolePermissionsProps = Omit<UseGetProps<PermissionsResponse, APIErrorResponse, void, ListRolePermissionsPathParams>, "path"> & ListRolePermissionsPathParams;

/**
 * List permissions for a role
 * 
 * Returns a list of all permissions for a single role.
 */
export const useListRolePermissions = ({role_id, ...props}: UseListRolePermissionsProps) => useGet<PermissionsResponse, APIErrorResponse, void, ListRolePermissionsPathParams>((paramsInPath: ListRolePermissionsPathParams) => `/api/v2/roles/${paramsInPath.role_id}/permissions`, {  pathParams: { role_id }, ...props });

/**
 * List permissions for a role
 * 
 * Returns a list of all permissions for a single role.
 */
export const listRolePermissionsPromise = (props: void) => HttpGET<PermissionsResponse, void>('/api/v2/roles/${role_id}/permissions', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface AddPermissionToRolePathParams {
  /**
   * The ID of the role.
   */
  role_id: string
}

export type AddPermissionToRoleProps = Omit<MutateProps<PermissionsResponse, APIErrorResponse, void, RelationshipToPermission, AddPermissionToRolePathParams>, "path" | "verb"> & AddPermissionToRolePathParams;

/**
 * Grant permission to a role
 * 
 * Adds a permission to a role.
 */
export const AddPermissionToRole = ({role_id, ...props}: AddPermissionToRoleProps) => (
  <Mutate<PermissionsResponse, APIErrorResponse, void, RelationshipToPermission, AddPermissionToRolePathParams>
    verb="POST"
    path={`/api/v2/roles/${role_id}/permissions`}
    
    {...props}
  />
);

export type UseAddPermissionToRoleProps = Omit<UseMutateProps<PermissionsResponse, APIErrorResponse, void, RelationshipToPermission, AddPermissionToRolePathParams>, "path" | "verb"> & AddPermissionToRolePathParams;

/**
 * Grant permission to a role
 * 
 * Adds a permission to a role.
 */
export const useAddPermissionToRole = ({role_id, ...props}: UseAddPermissionToRoleProps) => useMutate<PermissionsResponse, APIErrorResponse, void, RelationshipToPermission, AddPermissionToRolePathParams>("POST", (paramsInPath: AddPermissionToRolePathParams) => `/api/v2/roles/${paramsInPath.role_id}/permissions`, {  pathParams: { role_id }, ...props });

export type AddPermissionToRolePromiseProps = Omit<RelationshipToPermission, "_authentication_token">;
/**
 * Grant permission to a role
 * 
 * Adds a permission to a role.
 */
export const addPermissionToRolePromise = (props: AddPermissionToRolePromiseProps) => HttpPOST<PermissionsResponse, AddPermissionToRolePromiseProps>('/api/v2/roles/${role_id}/permissions')(props);


export interface RemoveUserFromRolePathParams {
  /**
   * The ID of the role.
   */
  role_id: string
}

export type RemoveUserFromRoleProps = Omit<MutateProps<UsersResponse, APIErrorResponse, void, RelationshipToUser, RemoveUserFromRolePathParams>, "path" | "verb"> & RemoveUserFromRolePathParams;

/**
 * Remove a user from a role
 * 
 * Removes a user from a role.
 */
export const RemoveUserFromRole = ({role_id, ...props}: RemoveUserFromRoleProps) => (
  <Mutate<UsersResponse, APIErrorResponse, void, RelationshipToUser, RemoveUserFromRolePathParams>
    verb="DELETE"
    path={`/api/v2/roles/${role_id}/users`}
    
    {...props}
  />
);

export type UseRemoveUserFromRoleProps = Omit<UseMutateProps<UsersResponse, APIErrorResponse, void, RelationshipToUser, RemoveUserFromRolePathParams>, "path" | "verb"> & RemoveUserFromRolePathParams;

/**
 * Remove a user from a role
 * 
 * Removes a user from a role.
 */
export const useRemoveUserFromRole = ({role_id, ...props}: UseRemoveUserFromRoleProps) => useMutate<UsersResponse, APIErrorResponse, void, RelationshipToUser, RemoveUserFromRolePathParams>("DELETE", (paramsInPath: RemoveUserFromRolePathParams) => `/api/v2/roles/${paramsInPath.role_id}/users`, {  pathParams: { role_id }, ...props });


export interface ListRoleUsersQueryParams {
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific page number to return.
   */
  "page[number]"?: number;
  /**
   * User attribute to order results by. Sort order is **ascending** by default.
   * Sort order is **descending** if the field is prefixed by a negative sign,
   * for example `sort=-name`. Options: `name`, `email`, `status`.
   */
  sort?: string;
  /**
   * Filter all users by the given string. Defaults to no filtering.
   */
  filter?: string;
}

export interface ListRoleUsersPathParams {
  /**
   * The ID of the role.
   */
  role_id: string
}

export type ListRoleUsersProps = Omit<GetProps<UsersResponse, APIErrorResponse, ListRoleUsersQueryParams, ListRoleUsersPathParams>, "path"> & ListRoleUsersPathParams;

/**
 * Get all users of a role
 * 
 * Gets all users of a role.
 */
export const ListRoleUsers = ({role_id, ...props}: ListRoleUsersProps) => (
  <Get<UsersResponse, APIErrorResponse, ListRoleUsersQueryParams, ListRoleUsersPathParams>
    path={`/api/v2/roles/${role_id}/users`}
    
    {...props}
  />
);

export type UseListRoleUsersProps = Omit<UseGetProps<UsersResponse, APIErrorResponse, ListRoleUsersQueryParams, ListRoleUsersPathParams>, "path"> & ListRoleUsersPathParams;

/**
 * Get all users of a role
 * 
 * Gets all users of a role.
 */
export const useListRoleUsers = ({role_id, ...props}: UseListRoleUsersProps) => useGet<UsersResponse, APIErrorResponse, ListRoleUsersQueryParams, ListRoleUsersPathParams>((paramsInPath: ListRoleUsersPathParams) => `/api/v2/roles/${paramsInPath.role_id}/users`, {  pathParams: { role_id }, ...props });

/**
 * Get all users of a role
 * 
 * Gets all users of a role.
 */
export const listRoleUsersPromise = (props: ListRoleUsersQueryParams) => HttpGET<UsersResponse, ListRoleUsersQueryParams>('/api/v2/roles/${role_id}/users', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface AddUserToRolePathParams {
  /**
   * The ID of the role.
   */
  role_id: string
}

export type AddUserToRoleProps = Omit<MutateProps<UsersResponse, APIErrorResponse, void, RelationshipToUser, AddUserToRolePathParams>, "path" | "verb"> & AddUserToRolePathParams;

/**
 * Add a user to a role
 * 
 * Adds a user to a role.
 */
export const AddUserToRole = ({role_id, ...props}: AddUserToRoleProps) => (
  <Mutate<UsersResponse, APIErrorResponse, void, RelationshipToUser, AddUserToRolePathParams>
    verb="POST"
    path={`/api/v2/roles/${role_id}/users`}
    
    {...props}
  />
);

export type UseAddUserToRoleProps = Omit<UseMutateProps<UsersResponse, APIErrorResponse, void, RelationshipToUser, AddUserToRolePathParams>, "path" | "verb"> & AddUserToRolePathParams;

/**
 * Add a user to a role
 * 
 * Adds a user to a role.
 */
export const useAddUserToRole = ({role_id, ...props}: UseAddUserToRoleProps) => useMutate<UsersResponse, APIErrorResponse, void, RelationshipToUser, AddUserToRolePathParams>("POST", (paramsInPath: AddUserToRolePathParams) => `/api/v2/roles/${paramsInPath.role_id}/users`, {  pathParams: { role_id }, ...props });

export type AddUserToRolePromiseProps = Omit<RelationshipToUser, "_authentication_token">;
/**
 * Add a user to a role
 * 
 * Adds a user to a role.
 */
export const addUserToRolePromise = (props: AddUserToRolePromiseProps) => HttpPOST<UsersResponse, AddUserToRolePromiseProps>('/api/v2/roles/${role_id}/users')(props);


export type ListSecurityFiltersProps = Omit<GetProps<SecurityFiltersResponse, NotAuthorizedResponseResponse | TooManyRequestsResponseResponse, void, void>, "path">;

/**
 * Get all security filters
 * 
 * Get the list of configured security filters with their definitions.
 */
export const ListSecurityFilters = (props: ListSecurityFiltersProps) => (
  <Get<SecurityFiltersResponse, NotAuthorizedResponseResponse | TooManyRequestsResponseResponse, void, void>
    path={`/api/v2/security_monitoring/configuration/security_filters`}
    
    {...props}
  />
);

export type UseListSecurityFiltersProps = Omit<UseGetProps<SecurityFiltersResponse, NotAuthorizedResponseResponse | TooManyRequestsResponseResponse, void, void>, "path">;

/**
 * Get all security filters
 * 
 * Get the list of configured security filters with their definitions.
 */
export const useListSecurityFilters = (props: UseListSecurityFiltersProps) => useGet<SecurityFiltersResponse, NotAuthorizedResponseResponse | TooManyRequestsResponseResponse, void, void>(`/api/v2/security_monitoring/configuration/security_filters`, props);

/**
 * Get all security filters
 * 
 * Get the list of configured security filters with their definitions.
 */
export const listSecurityFiltersPromise = (props: void) => HttpGET<SecurityFiltersResponse, void>('/api/v2/security_monitoring/configuration/security_filters', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateSecurityFilterProps = Omit<MutateProps<SecurityFilterResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | ConflictResponseResponse | TooManyRequestsResponseResponse, void, SecurityFilterCreateRequest, void>, "path" | "verb">;

/**
 * Create a security filter
 * 
 * Create a security filter.
 * 
 * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
 * for more examples.
 */
export const CreateSecurityFilter = (props: CreateSecurityFilterProps) => (
  <Mutate<SecurityFilterResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | ConflictResponseResponse | TooManyRequestsResponseResponse, void, SecurityFilterCreateRequest, void>
    verb="POST"
    path={`/api/v2/security_monitoring/configuration/security_filters`}
    
    {...props}
  />
);

export type UseCreateSecurityFilterProps = Omit<UseMutateProps<SecurityFilterResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | ConflictResponseResponse | TooManyRequestsResponseResponse, void, SecurityFilterCreateRequest, void>, "path" | "verb">;

/**
 * Create a security filter
 * 
 * Create a security filter.
 * 
 * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
 * for more examples.
 */
export const useCreateSecurityFilter = (props: UseCreateSecurityFilterProps) => useMutate<SecurityFilterResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | ConflictResponseResponse | TooManyRequestsResponseResponse, void, SecurityFilterCreateRequest, void>("POST", `/api/v2/security_monitoring/configuration/security_filters`, props);

export type CreateSecurityFilterPromiseProps = Omit<SecurityFilterCreateRequest, "_authentication_token">;
/**
 * Create a security filter
 * 
 * Create a security filter.
 * 
 * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
 * for more examples.
 */
export const createSecurityFilterPromise = (props: CreateSecurityFilterPromiseProps) => HttpPOST<SecurityFilterResponse, CreateSecurityFilterPromiseProps>('/api/v2/security_monitoring/configuration/security_filters')(props);


export type DeleteSecurityFilterProps = Omit<MutateProps<void, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a security filter
 * 
 * Delete a specific security filter.
 */
export const DeleteSecurityFilter = (props: DeleteSecurityFilterProps) => (
  <Mutate<void, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/security_monitoring/configuration/security_filters`}
    
    {...props}
  />
);

export type UseDeleteSecurityFilterProps = Omit<UseMutateProps<void, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete a security filter
 * 
 * Delete a specific security filter.
 */
export const useDeleteSecurityFilter = (props: UseDeleteSecurityFilterProps) => useMutate<void, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, string, void>("DELETE", `/api/v2/security_monitoring/configuration/security_filters`, {   ...props });


export interface GetSecurityFilterPathParams {
  /**
   * The ID of the security filter.
   */
  security_filter_id: string
}

export type GetSecurityFilterProps = Omit<GetProps<SecurityFilterResponse, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, GetSecurityFilterPathParams>, "path"> & GetSecurityFilterPathParams;

/**
 * Get a security filter
 * 
 * Get the details of a specific security filter.
 * 
 * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
 * for more examples.
 */
export const GetSecurityFilter = ({security_filter_id, ...props}: GetSecurityFilterProps) => (
  <Get<SecurityFilterResponse, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, GetSecurityFilterPathParams>
    path={`/api/v2/security_monitoring/configuration/security_filters/${security_filter_id}`}
    
    {...props}
  />
);

export type UseGetSecurityFilterProps = Omit<UseGetProps<SecurityFilterResponse, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, GetSecurityFilterPathParams>, "path"> & GetSecurityFilterPathParams;

/**
 * Get a security filter
 * 
 * Get the details of a specific security filter.
 * 
 * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
 * for more examples.
 */
export const useGetSecurityFilter = ({security_filter_id, ...props}: UseGetSecurityFilterProps) => useGet<SecurityFilterResponse, NotAuthorizedResponseResponse | NotFoundResponseResponse | TooManyRequestsResponseResponse, void, GetSecurityFilterPathParams>((paramsInPath: GetSecurityFilterPathParams) => `/api/v2/security_monitoring/configuration/security_filters/${paramsInPath.security_filter_id}`, {  pathParams: { security_filter_id }, ...props });

/**
 * Get a security filter
 * 
 * Get the details of a specific security filter.
 * 
 * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
 * for more examples.
 */
export const getSecurityFilterPromise = (props: void) => HttpGET<SecurityFilterResponse, void>('/api/v2/security_monitoring/configuration/security_filters/${security_filter_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateSecurityFilterPathParams {
  /**
   * The ID of the security filter.
   */
  security_filter_id: string
}

export type UpdateSecurityFilterProps = Omit<MutateProps<SecurityFilterResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse | ConcurrentModificationResponseResponse | TooManyRequestsResponseResponse, void, SecurityFilterUpdateRequest, UpdateSecurityFilterPathParams>, "path" | "verb"> & UpdateSecurityFilterPathParams;

/**
 * Update a security filter
 * 
 * Update a specific security filter.
 * Returns the security filter object when the request is successful.
 */
export const UpdateSecurityFilter = ({security_filter_id, ...props}: UpdateSecurityFilterProps) => (
  <Mutate<SecurityFilterResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse | ConcurrentModificationResponseResponse | TooManyRequestsResponseResponse, void, SecurityFilterUpdateRequest, UpdateSecurityFilterPathParams>
    verb="PATCH"
    path={`/api/v2/security_monitoring/configuration/security_filters/${security_filter_id}`}
    
    {...props}
  />
);

export type UseUpdateSecurityFilterProps = Omit<UseMutateProps<SecurityFilterResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse | ConcurrentModificationResponseResponse | TooManyRequestsResponseResponse, void, SecurityFilterUpdateRequest, UpdateSecurityFilterPathParams>, "path" | "verb"> & UpdateSecurityFilterPathParams;

/**
 * Update a security filter
 * 
 * Update a specific security filter.
 * Returns the security filter object when the request is successful.
 */
export const useUpdateSecurityFilter = ({security_filter_id, ...props}: UseUpdateSecurityFilterProps) => useMutate<SecurityFilterResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse | ConcurrentModificationResponseResponse | TooManyRequestsResponseResponse, void, SecurityFilterUpdateRequest, UpdateSecurityFilterPathParams>("PATCH", (paramsInPath: UpdateSecurityFilterPathParams) => `/api/v2/security_monitoring/configuration/security_filters/${paramsInPath.security_filter_id}`, {  pathParams: { security_filter_id }, ...props });


export interface ListSecurityMonitoringRulesQueryParams {
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific page number to return.
   */
  "page[number]"?: number;
}

export type ListSecurityMonitoringRulesProps = Omit<GetProps<SecurityMonitoringListRulesResponse, BadRequestResponseResponse, ListSecurityMonitoringRulesQueryParams, void>, "path">;

/**
 * List rules
 * 
 * List rules.
 */
export const ListSecurityMonitoringRules = (props: ListSecurityMonitoringRulesProps) => (
  <Get<SecurityMonitoringListRulesResponse, BadRequestResponseResponse, ListSecurityMonitoringRulesQueryParams, void>
    path={`/api/v2/security_monitoring/rules`}
    
    {...props}
  />
);

export type UseListSecurityMonitoringRulesProps = Omit<UseGetProps<SecurityMonitoringListRulesResponse, BadRequestResponseResponse, ListSecurityMonitoringRulesQueryParams, void>, "path">;

/**
 * List rules
 * 
 * List rules.
 */
export const useListSecurityMonitoringRules = (props: UseListSecurityMonitoringRulesProps) => useGet<SecurityMonitoringListRulesResponse, BadRequestResponseResponse, ListSecurityMonitoringRulesQueryParams, void>(`/api/v2/security_monitoring/rules`, props);

/**
 * List rules
 * 
 * List rules.
 */
export const listSecurityMonitoringRulesPromise = (props: ListSecurityMonitoringRulesQueryParams) => HttpGET<SecurityMonitoringListRulesResponse, ListSecurityMonitoringRulesQueryParams>('/api/v2/security_monitoring/rules', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateSecurityMonitoringRuleProps = Omit<MutateProps<SecurityMonitoringRuleResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, SecurityMonitoringRuleCreatePayload, void>, "path" | "verb">;

/**
 * Create a detection rule
 * 
 * Create a detection rule.
 */
export const CreateSecurityMonitoringRule = (props: CreateSecurityMonitoringRuleProps) => (
  <Mutate<SecurityMonitoringRuleResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, SecurityMonitoringRuleCreatePayload, void>
    verb="POST"
    path={`/api/v2/security_monitoring/rules`}
    
    {...props}
  />
);

export type UseCreateSecurityMonitoringRuleProps = Omit<UseMutateProps<SecurityMonitoringRuleResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, SecurityMonitoringRuleCreatePayload, void>, "path" | "verb">;

/**
 * Create a detection rule
 * 
 * Create a detection rule.
 */
export const useCreateSecurityMonitoringRule = (props: UseCreateSecurityMonitoringRuleProps) => useMutate<SecurityMonitoringRuleResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, SecurityMonitoringRuleCreatePayload, void>("POST", `/api/v2/security_monitoring/rules`, props);

export type CreateSecurityMonitoringRulePromiseProps = Omit<SecurityMonitoringRuleCreatePayload, "_authentication_token">;
/**
 * Create a detection rule
 * 
 * Create a detection rule.
 */
export const createSecurityMonitoringRulePromise = (props: CreateSecurityMonitoringRulePromiseProps) => HttpPOST<SecurityMonitoringRuleResponse, CreateSecurityMonitoringRulePromiseProps>('/api/v2/security_monitoring/rules')(props);


export type DeleteSecurityMonitoringRuleProps = Omit<MutateProps<void, NotAuthorizedResponseResponse | NotFoundResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an existing rule
 * 
 * Delete an existing rule. Default rules cannot be deleted.
 */
export const DeleteSecurityMonitoringRule = (props: DeleteSecurityMonitoringRuleProps) => (
  <Mutate<void, NotAuthorizedResponseResponse | NotFoundResponseResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/security_monitoring/rules`}
    
    {...props}
  />
);

export type UseDeleteSecurityMonitoringRuleProps = Omit<UseMutateProps<void, NotAuthorizedResponseResponse | NotFoundResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an existing rule
 * 
 * Delete an existing rule. Default rules cannot be deleted.
 */
export const useDeleteSecurityMonitoringRule = (props: UseDeleteSecurityMonitoringRuleProps) => useMutate<void, NotAuthorizedResponseResponse | NotFoundResponseResponse, void, string, void>("DELETE", `/api/v2/security_monitoring/rules`, {   ...props });


export interface GetSecurityMonitoringRulePathParams {
  /**
   * The ID of the rule.
   */
  rule_id: string
}

export type GetSecurityMonitoringRuleProps = Omit<GetProps<SecurityMonitoringRuleResponse, NotFoundResponseResponse, void, GetSecurityMonitoringRulePathParams>, "path"> & GetSecurityMonitoringRulePathParams;

/**
 * Get a rule's details
 * 
 * Get a rule's details.
 */
export const GetSecurityMonitoringRule = ({rule_id, ...props}: GetSecurityMonitoringRuleProps) => (
  <Get<SecurityMonitoringRuleResponse, NotFoundResponseResponse, void, GetSecurityMonitoringRulePathParams>
    path={`/api/v2/security_monitoring/rules/${rule_id}`}
    
    {...props}
  />
);

export type UseGetSecurityMonitoringRuleProps = Omit<UseGetProps<SecurityMonitoringRuleResponse, NotFoundResponseResponse, void, GetSecurityMonitoringRulePathParams>, "path"> & GetSecurityMonitoringRulePathParams;

/**
 * Get a rule's details
 * 
 * Get a rule's details.
 */
export const useGetSecurityMonitoringRule = ({rule_id, ...props}: UseGetSecurityMonitoringRuleProps) => useGet<SecurityMonitoringRuleResponse, NotFoundResponseResponse, void, GetSecurityMonitoringRulePathParams>((paramsInPath: GetSecurityMonitoringRulePathParams) => `/api/v2/security_monitoring/rules/${paramsInPath.rule_id}`, {  pathParams: { rule_id }, ...props });

/**
 * Get a rule's details
 * 
 * Get a rule's details.
 */
export const getSecurityMonitoringRulePromise = (props: void) => HttpGET<SecurityMonitoringRuleResponse, void>('/api/v2/security_monitoring/rules/${rule_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateSecurityMonitoringRulePathParams {
  /**
   * The ID of the rule.
   */
  rule_id: string
}

export type UpdateSecurityMonitoringRuleProps = Omit<MutateProps<SecurityMonitoringRuleResponse, BadRequestResponseResponse | ConcurrentModificationResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse, void, SecurityMonitoringRuleUpdatePayload, UpdateSecurityMonitoringRulePathParams>, "path" | "verb"> & UpdateSecurityMonitoringRulePathParams;

/**
 * Update an existing rule
 * 
 * Update an existing rule. When updating `cases`, `queries` or `options`, the whole field
 * must be included. For example, when modifying a query all queries must be included.
 * Default rules can only be updated to be enabled and to change notifications.
 */
export const UpdateSecurityMonitoringRule = ({rule_id, ...props}: UpdateSecurityMonitoringRuleProps) => (
  <Mutate<SecurityMonitoringRuleResponse, BadRequestResponseResponse | ConcurrentModificationResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse, void, SecurityMonitoringRuleUpdatePayload, UpdateSecurityMonitoringRulePathParams>
    verb="PUT"
    path={`/api/v2/security_monitoring/rules/${rule_id}`}
    
    {...props}
  />
);

export type UseUpdateSecurityMonitoringRuleProps = Omit<UseMutateProps<SecurityMonitoringRuleResponse, BadRequestResponseResponse | ConcurrentModificationResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse, void, SecurityMonitoringRuleUpdatePayload, UpdateSecurityMonitoringRulePathParams>, "path" | "verb"> & UpdateSecurityMonitoringRulePathParams;

/**
 * Update an existing rule
 * 
 * Update an existing rule. When updating `cases`, `queries` or `options`, the whole field
 * must be included. For example, when modifying a query all queries must be included.
 * Default rules can only be updated to be enabled and to change notifications.
 */
export const useUpdateSecurityMonitoringRule = ({rule_id, ...props}: UseUpdateSecurityMonitoringRuleProps) => useMutate<SecurityMonitoringRuleResponse, BadRequestResponseResponse | ConcurrentModificationResponseResponse | NotAuthorizedResponseResponse | NotFoundResponseResponse, void, SecurityMonitoringRuleUpdatePayload, UpdateSecurityMonitoringRulePathParams>("PUT", (paramsInPath: UpdateSecurityMonitoringRulePathParams) => `/api/v2/security_monitoring/rules/${paramsInPath.rule_id}`, {  pathParams: { rule_id }, ...props });


export interface ListSecurityMonitoringSignalsQueryParams {
  /**
   * The search query for security signals.
   */
  "filter[query]"?: string;
  /**
   * The minimum timestamp for requested security signals.
   */
  "filter[from]"?: string;
  /**
   * The maximum timestamp for requested security signals.
   */
  "filter[to]"?: string;
  /**
   * The order of the security signals in results.
   */
  sort?: SecurityMonitoringSignalsSort;
  /**
   * A list of results using the cursor provided in the previous query.
   */
  "page[cursor]"?: string;
  /**
   * The maximum number of security signals in the response.
   */
  "page[limit]"?: number;
}

export type ListSecurityMonitoringSignalsProps = Omit<GetProps<SecurityMonitoringSignalsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, ListSecurityMonitoringSignalsQueryParams, void>, "path">;

/**
 * Get a quick list of security signals
 * 
 * The list endpoint returns security signals that match a search query.
 * Both this endpoint and the POST endpoint can be used interchangeably when listing
 * security signals.
 */
export const ListSecurityMonitoringSignals = (props: ListSecurityMonitoringSignalsProps) => (
  <Get<SecurityMonitoringSignalsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, ListSecurityMonitoringSignalsQueryParams, void>
    path={`/api/v2/security_monitoring/signals`}
    
    {...props}
  />
);

export type UseListSecurityMonitoringSignalsProps = Omit<UseGetProps<SecurityMonitoringSignalsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, ListSecurityMonitoringSignalsQueryParams, void>, "path">;

/**
 * Get a quick list of security signals
 * 
 * The list endpoint returns security signals that match a search query.
 * Both this endpoint and the POST endpoint can be used interchangeably when listing
 * security signals.
 */
export const useListSecurityMonitoringSignals = (props: UseListSecurityMonitoringSignalsProps) => useGet<SecurityMonitoringSignalsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, ListSecurityMonitoringSignalsQueryParams, void>(`/api/v2/security_monitoring/signals`, props);

/**
 * Get a quick list of security signals
 * 
 * The list endpoint returns security signals that match a search query.
 * Both this endpoint and the POST endpoint can be used interchangeably when listing
 * security signals.
 */
export const listSecurityMonitoringSignalsPromise = (props: ListSecurityMonitoringSignalsQueryParams) => HttpGET<SecurityMonitoringSignalsListResponse, ListSecurityMonitoringSignalsQueryParams>('/api/v2/security_monitoring/signals', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type SearchSecurityMonitoringSignalsProps = Omit<MutateProps<SecurityMonitoringSignalsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, SecurityMonitoringSignalListRequest, void>, "path" | "verb">;

/**
 * Get a list of security signals
 * 
 * Returns security signals that match a search query.
 * Both this endpoint and the GET endpoint can be used interchangeably for listing
 * security signals.
 */
export const SearchSecurityMonitoringSignals = (props: SearchSecurityMonitoringSignalsProps) => (
  <Mutate<SecurityMonitoringSignalsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, SecurityMonitoringSignalListRequest, void>
    verb="POST"
    path={`/api/v2/security_monitoring/signals/search`}
    
    {...props}
  />
);

export type UseSearchSecurityMonitoringSignalsProps = Omit<UseMutateProps<SecurityMonitoringSignalsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, SecurityMonitoringSignalListRequest, void>, "path" | "verb">;

/**
 * Get a list of security signals
 * 
 * Returns security signals that match a search query.
 * Both this endpoint and the GET endpoint can be used interchangeably for listing
 * security signals.
 */
export const useSearchSecurityMonitoringSignals = (props: UseSearchSecurityMonitoringSignalsProps) => useMutate<SecurityMonitoringSignalsListResponse, BadRequestResponseResponse | NotAuthorizedResponseResponse, void, SecurityMonitoringSignalListRequest, void>("POST", `/api/v2/security_monitoring/signals/search`, props);

export type SearchSecurityMonitoringSignalsPromiseProps = Omit<SecurityMonitoringSignalListRequest, "_authentication_token">;
/**
 * Get a list of security signals
 * 
 * Returns security signals that match a search query.
 * Both this endpoint and the GET endpoint can be used interchangeably for listing
 * security signals.
 */
export const searchSecurityMonitoringSignalsPromise = (props: SearchSecurityMonitoringSignalsPromiseProps) => HttpPOST<SecurityMonitoringSignalsListResponse, SearchSecurityMonitoringSignalsPromiseProps>('/api/v2/security_monitoring/signals/search')(props);


export type CreateServiceAccountProps = Omit<MutateProps<UserResponse, APIErrorResponse, void, ServiceAccountCreateRequest, void>, "path" | "verb">;

/**
 * Create a service account
 * 
 * Create a service account for your organization.
 */
export const CreateServiceAccount = (props: CreateServiceAccountProps) => (
  <Mutate<UserResponse, APIErrorResponse, void, ServiceAccountCreateRequest, void>
    verb="POST"
    path={`/api/v2/service_accounts`}
    
    {...props}
  />
);

export type UseCreateServiceAccountProps = Omit<UseMutateProps<UserResponse, APIErrorResponse, void, ServiceAccountCreateRequest, void>, "path" | "verb">;

/**
 * Create a service account
 * 
 * Create a service account for your organization.
 */
export const useCreateServiceAccount = (props: UseCreateServiceAccountProps) => useMutate<UserResponse, APIErrorResponse, void, ServiceAccountCreateRequest, void>("POST", `/api/v2/service_accounts`, props);

export type CreateServiceAccountPromiseProps = Omit<ServiceAccountCreateRequest, "_authentication_token">;
/**
 * Create a service account
 * 
 * Create a service account for your organization.
 */
export const createServiceAccountPromise = (props: CreateServiceAccountPromiseProps) => HttpPOST<UserResponse, CreateServiceAccountPromiseProps>('/api/v2/service_accounts')(props);


export interface ListServiceAccountApplicationKeysQueryParams {
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific page number to return.
   */
  "page[number]"?: number;
  /**
   * Application key attribute used to sort results. Sort order is ascending
   * by default. In order to specify a descending sort, prefix the
   * attribute with a minus sign.
   */
  sort?: ApplicationKeysSort;
  /**
   * Filter application keys by the specified string.
   */
  filter?: string;
  /**
   * Only include application keys created on or after the specified date.
   */
  "filter[created_at][start]"?: string;
  /**
   * Only include application keys created on or before the specified date.
   */
  "filter[created_at][end]"?: string;
}

export interface ListServiceAccountApplicationKeysPathParams {
  /**
   * The ID of the service account.
   */
  service_account_id: string
}

export type ListServiceAccountApplicationKeysProps = Omit<GetProps<ListApplicationKeysResponse, APIErrorResponse, ListServiceAccountApplicationKeysQueryParams, ListServiceAccountApplicationKeysPathParams>, "path"> & ListServiceAccountApplicationKeysPathParams;

/**
 * List application keys for this service account
 * 
 * List all application keys available for this service account.
 */
export const ListServiceAccountApplicationKeys = ({service_account_id, ...props}: ListServiceAccountApplicationKeysProps) => (
  <Get<ListApplicationKeysResponse, APIErrorResponse, ListServiceAccountApplicationKeysQueryParams, ListServiceAccountApplicationKeysPathParams>
    path={`/api/v2/service_accounts/${service_account_id}/application_keys`}
    
    {...props}
  />
);

export type UseListServiceAccountApplicationKeysProps = Omit<UseGetProps<ListApplicationKeysResponse, APIErrorResponse, ListServiceAccountApplicationKeysQueryParams, ListServiceAccountApplicationKeysPathParams>, "path"> & ListServiceAccountApplicationKeysPathParams;

/**
 * List application keys for this service account
 * 
 * List all application keys available for this service account.
 */
export const useListServiceAccountApplicationKeys = ({service_account_id, ...props}: UseListServiceAccountApplicationKeysProps) => useGet<ListApplicationKeysResponse, APIErrorResponse, ListServiceAccountApplicationKeysQueryParams, ListServiceAccountApplicationKeysPathParams>((paramsInPath: ListServiceAccountApplicationKeysPathParams) => `/api/v2/service_accounts/${paramsInPath.service_account_id}/application_keys`, {  pathParams: { service_account_id }, ...props });

/**
 * List application keys for this service account
 * 
 * List all application keys available for this service account.
 */
export const listServiceAccountApplicationKeysPromise = (props: ListServiceAccountApplicationKeysQueryParams) => HttpGET<ListApplicationKeysResponse, ListServiceAccountApplicationKeysQueryParams>('/api/v2/service_accounts/${service_account_id}/application_keys', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface CreateServiceAccountApplicationKeyPathParams {
  /**
   * The ID of the service account.
   */
  service_account_id: string
}

export type CreateServiceAccountApplicationKeyProps = Omit<MutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyCreateRequest, CreateServiceAccountApplicationKeyPathParams>, "path" | "verb"> & CreateServiceAccountApplicationKeyPathParams;

/**
 * Create an application key for this service account
 * 
 * Create an application key for this service account.
 */
export const CreateServiceAccountApplicationKey = ({service_account_id, ...props}: CreateServiceAccountApplicationKeyProps) => (
  <Mutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyCreateRequest, CreateServiceAccountApplicationKeyPathParams>
    verb="POST"
    path={`/api/v2/service_accounts/${service_account_id}/application_keys`}
    
    {...props}
  />
);

export type UseCreateServiceAccountApplicationKeyProps = Omit<UseMutateProps<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyCreateRequest, CreateServiceAccountApplicationKeyPathParams>, "path" | "verb"> & CreateServiceAccountApplicationKeyPathParams;

/**
 * Create an application key for this service account
 * 
 * Create an application key for this service account.
 */
export const useCreateServiceAccountApplicationKey = ({service_account_id, ...props}: UseCreateServiceAccountApplicationKeyProps) => useMutate<ApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyCreateRequest, CreateServiceAccountApplicationKeyPathParams>("POST", (paramsInPath: CreateServiceAccountApplicationKeyPathParams) => `/api/v2/service_accounts/${paramsInPath.service_account_id}/application_keys`, {  pathParams: { service_account_id }, ...props });

export type CreateServiceAccountApplicationKeyPromiseProps = Omit<ApplicationKeyCreateRequest, "_authentication_token">;
/**
 * Create an application key for this service account
 * 
 * Create an application key for this service account.
 */
export const createServiceAccountApplicationKeyPromise = (props: CreateServiceAccountApplicationKeyPromiseProps) => HttpPOST<ApplicationKeyResponse, CreateServiceAccountApplicationKeyPromiseProps>('/api/v2/service_accounts/${service_account_id}/application_keys')(props);


export interface DeleteServiceAccountApplicationKeyPathParams {
  /**
   * The ID of the service account.
   */
  service_account_id: string
}

export type DeleteServiceAccountApplicationKeyProps = Omit<MutateProps<void, APIErrorResponse, void, string, DeleteServiceAccountApplicationKeyPathParams>, "path" | "verb"> & DeleteServiceAccountApplicationKeyPathParams;

/**
 * Delete an application key for this service account
 * 
 * Delete an application key owned by this service account.
 */
export const DeleteServiceAccountApplicationKey = ({service_account_id, ...props}: DeleteServiceAccountApplicationKeyProps) => (
  <Mutate<void, APIErrorResponse, void, string, DeleteServiceAccountApplicationKeyPathParams>
    verb="DELETE"
    path={`/api/v2/service_accounts/${service_account_id}/application_keys`}
    
    {...props}
  />
);

export type UseDeleteServiceAccountApplicationKeyProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, DeleteServiceAccountApplicationKeyPathParams>, "path" | "verb"> & DeleteServiceAccountApplicationKeyPathParams;

/**
 * Delete an application key for this service account
 * 
 * Delete an application key owned by this service account.
 */
export const useDeleteServiceAccountApplicationKey = ({service_account_id, ...props}: UseDeleteServiceAccountApplicationKeyProps) => useMutate<void, APIErrorResponse, void, string, DeleteServiceAccountApplicationKeyPathParams>("DELETE", (paramsInPath: DeleteServiceAccountApplicationKeyPathParams) => `/api/v2/service_accounts/${paramsInPath.service_account_id}/application_keys`, {  pathParams: { service_account_id }, ...props });


export interface GetServiceAccountApplicationKeyPathParams {
  /**
   * The ID of the service account.
   */
  service_account_id: string;
  /**
   * The ID of the application key.
   */
  app_key_id: string
}

export type GetServiceAccountApplicationKeyProps = Omit<GetProps<PartialApplicationKeyResponse, APIErrorResponse, void, GetServiceAccountApplicationKeyPathParams>, "path"> & GetServiceAccountApplicationKeyPathParams;

/**
 * Get one application key for this service account
 * 
 * Get an application key owned by this service account.
 */
export const GetServiceAccountApplicationKey = ({service_account_id, app_key_id, ...props}: GetServiceAccountApplicationKeyProps) => (
  <Get<PartialApplicationKeyResponse, APIErrorResponse, void, GetServiceAccountApplicationKeyPathParams>
    path={`/api/v2/service_accounts/${service_account_id}/application_keys/${app_key_id}`}
    
    {...props}
  />
);

export type UseGetServiceAccountApplicationKeyProps = Omit<UseGetProps<PartialApplicationKeyResponse, APIErrorResponse, void, GetServiceAccountApplicationKeyPathParams>, "path"> & GetServiceAccountApplicationKeyPathParams;

/**
 * Get one application key for this service account
 * 
 * Get an application key owned by this service account.
 */
export const useGetServiceAccountApplicationKey = ({service_account_id, app_key_id, ...props}: UseGetServiceAccountApplicationKeyProps) => useGet<PartialApplicationKeyResponse, APIErrorResponse, void, GetServiceAccountApplicationKeyPathParams>((paramsInPath: GetServiceAccountApplicationKeyPathParams) => `/api/v2/service_accounts/${paramsInPath.service_account_id}/application_keys/${paramsInPath.app_key_id}`, {  pathParams: { service_account_id, app_key_id }, ...props });

/**
 * Get one application key for this service account
 * 
 * Get an application key owned by this service account.
 */
export const getServiceAccountApplicationKeyPromise = (props: void) => HttpGET<PartialApplicationKeyResponse, void>('/api/v2/service_accounts/${service_account_id}/application_keys/${app_key_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateServiceAccountApplicationKeyPathParams {
  /**
   * The ID of the service account.
   */
  service_account_id: string;
  /**
   * The ID of the application key.
   */
  app_key_id: string
}

export type UpdateServiceAccountApplicationKeyProps = Omit<MutateProps<PartialApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateServiceAccountApplicationKeyPathParams>, "path" | "verb"> & UpdateServiceAccountApplicationKeyPathParams;

/**
 * Edit an application key for this service account
 * 
 * Edit an application key owned by this service account.
 */
export const UpdateServiceAccountApplicationKey = ({service_account_id, app_key_id, ...props}: UpdateServiceAccountApplicationKeyProps) => (
  <Mutate<PartialApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateServiceAccountApplicationKeyPathParams>
    verb="PATCH"
    path={`/api/v2/service_accounts/${service_account_id}/application_keys/${app_key_id}`}
    
    {...props}
  />
);

export type UseUpdateServiceAccountApplicationKeyProps = Omit<UseMutateProps<PartialApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateServiceAccountApplicationKeyPathParams>, "path" | "verb"> & UpdateServiceAccountApplicationKeyPathParams;

/**
 * Edit an application key for this service account
 * 
 * Edit an application key owned by this service account.
 */
export const useUpdateServiceAccountApplicationKey = ({service_account_id, app_key_id, ...props}: UseUpdateServiceAccountApplicationKeyProps) => useMutate<PartialApplicationKeyResponse, APIErrorResponse, void, ApplicationKeyUpdateRequest, UpdateServiceAccountApplicationKeyPathParams>("PATCH", (paramsInPath: UpdateServiceAccountApplicationKeyPathParams) => `/api/v2/service_accounts/${paramsInPath.service_account_id}/application_keys/${paramsInPath.app_key_id}`, {  pathParams: { service_account_id, app_key_id }, ...props });


export interface ListIncidentServicesQueryParams {
  /**
   * Specifies which types of related objects should be included in the response.
   */
  include?: IncidentRelatedObject;
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific offset to use as the beginning of the returned page.
   */
  "page[offset]"?: number;
  /**
   * A search query that filters services by name.
   */
  filter?: string;
}

export type ListIncidentServicesProps = Omit<GetProps<IncidentServicesResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentServicesQueryParams, void>, "path">;

/**
 * Get a list of all incident services
 * 
 * Get all incident services uploaded for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident services.
 */
export const ListIncidentServices = (props: ListIncidentServicesProps) => (
  <Get<IncidentServicesResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentServicesQueryParams, void>
    path={`/api/v2/services`}
    
    {...props}
  />
);

export type UseListIncidentServicesProps = Omit<UseGetProps<IncidentServicesResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentServicesQueryParams, void>, "path">;

/**
 * Get a list of all incident services
 * 
 * Get all incident services uploaded for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident services.
 */
export const useListIncidentServices = (props: UseListIncidentServicesProps) => useGet<IncidentServicesResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentServicesQueryParams, void>(`/api/v2/services`, props);

/**
 * Get a list of all incident services
 * 
 * Get all incident services uploaded for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident services.
 */
export const listIncidentServicesPromise = (props: ListIncidentServicesQueryParams) => HttpGET<IncidentServicesResponse, ListIncidentServicesQueryParams>('/api/v2/services', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateIncidentServiceProps = Omit<MutateProps<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentServiceCreateRequest, void>, "path" | "verb">;

/**
 * Create a new incident service
 * 
 * Creates a new incident service.
 */
export const CreateIncidentService = (props: CreateIncidentServiceProps) => (
  <Mutate<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentServiceCreateRequest, void>
    verb="POST"
    path={`/api/v2/services`}
    
    {...props}
  />
);

export type UseCreateIncidentServiceProps = Omit<UseMutateProps<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentServiceCreateRequest, void>, "path" | "verb">;

/**
 * Create a new incident service
 * 
 * Creates a new incident service.
 */
export const useCreateIncidentService = (props: UseCreateIncidentServiceProps) => useMutate<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentServiceCreateRequest, void>("POST", `/api/v2/services`, props);

export type CreateIncidentServicePromiseProps = Omit<IncidentServiceCreateRequest, "_authentication_token">;
/**
 * Create a new incident service
 * 
 * Creates a new incident service.
 */
export const createIncidentServicePromise = (props: CreateIncidentServicePromiseProps) => HttpPOST<IncidentServiceResponse, CreateIncidentServicePromiseProps>('/api/v2/services')(props);


export type DeleteIncidentServiceProps = Omit<MutateProps<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an existing incident service
 * 
 * Deletes an existing incident service.
 */
export const DeleteIncidentService = (props: DeleteIncidentServiceProps) => (
  <Mutate<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/services`}
    
    {...props}
  />
);

export type UseDeleteIncidentServiceProps = Omit<UseMutateProps<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an existing incident service
 * 
 * Deletes an existing incident service.
 */
export const useDeleteIncidentService = (props: UseDeleteIncidentServiceProps) => useMutate<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>("DELETE", `/api/v2/services`, {   ...props });


export interface GetIncidentServiceQueryParams {
  /**
   * Specifies which types of related objects should be included in the response.
   */
  include?: IncidentRelatedObject;
}

export interface GetIncidentServicePathParams {
  /**
   * The ID of the incident service.
   */
  service_id: string
}

export type GetIncidentServiceProps = Omit<GetProps<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentServiceQueryParams, GetIncidentServicePathParams>, "path"> & GetIncidentServicePathParams;

/**
 * Get details of an incident service
 * 
 * Get details of an incident service. If the `include[users]` query parameter is provided,
 * the included attribute will contain the users related to these incident services.
 */
export const GetIncidentService = ({service_id, ...props}: GetIncidentServiceProps) => (
  <Get<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentServiceQueryParams, GetIncidentServicePathParams>
    path={`/api/v2/services/${service_id}`}
    
    {...props}
  />
);

export type UseGetIncidentServiceProps = Omit<UseGetProps<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentServiceQueryParams, GetIncidentServicePathParams>, "path"> & GetIncidentServicePathParams;

/**
 * Get details of an incident service
 * 
 * Get details of an incident service. If the `include[users]` query parameter is provided,
 * the included attribute will contain the users related to these incident services.
 */
export const useGetIncidentService = ({service_id, ...props}: UseGetIncidentServiceProps) => useGet<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentServiceQueryParams, GetIncidentServicePathParams>((paramsInPath: GetIncidentServicePathParams) => `/api/v2/services/${paramsInPath.service_id}`, {  pathParams: { service_id }, ...props });

/**
 * Get details of an incident service
 * 
 * Get details of an incident service. If the `include[users]` query parameter is provided,
 * the included attribute will contain the users related to these incident services.
 */
export const getIncidentServicePromise = (props: GetIncidentServiceQueryParams) => HttpGET<IncidentServiceResponse, GetIncidentServiceQueryParams>('/api/v2/services/${service_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateIncidentServicePathParams {
  /**
   * The ID of the incident service.
   */
  service_id: string
}

export type UpdateIncidentServiceProps = Omit<MutateProps<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentServiceUpdateRequest, UpdateIncidentServicePathParams>, "path" | "verb"> & UpdateIncidentServicePathParams;

/**
 * Update an existing incident service
 * 
 * Updates an existing incident service. Only provide the attributes which should be updated as this request is a partial update.
 */
export const UpdateIncidentService = ({service_id, ...props}: UpdateIncidentServiceProps) => (
  <Mutate<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentServiceUpdateRequest, UpdateIncidentServicePathParams>
    verb="PATCH"
    path={`/api/v2/services/${service_id}`}
    
    {...props}
  />
);

export type UseUpdateIncidentServiceProps = Omit<UseMutateProps<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentServiceUpdateRequest, UpdateIncidentServicePathParams>, "path" | "verb"> & UpdateIncidentServicePathParams;

/**
 * Update an existing incident service
 * 
 * Updates an existing incident service. Only provide the attributes which should be updated as this request is a partial update.
 */
export const useUpdateIncidentService = ({service_id, ...props}: UseUpdateIncidentServiceProps) => useMutate<IncidentServiceResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentServiceUpdateRequest, UpdateIncidentServicePathParams>("PATCH", (paramsInPath: UpdateIncidentServicePathParams) => `/api/v2/services/${paramsInPath.service_id}`, {  pathParams: { service_id }, ...props });


export interface ListIncidentTeamsQueryParams {
  /**
   * Specifies which types of related objects should be included in the response.
   */
  include?: IncidentRelatedObject;
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific offset to use as the beginning of the returned page.
   */
  "page[offset]"?: number;
  /**
   * A search query that filters teams by name.
   */
  filter?: string;
}

export type ListIncidentTeamsProps = Omit<GetProps<IncidentTeamsResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentTeamsQueryParams, void>, "path">;

/**
 * Get a list of all incident teams
 * 
 * Get all incident teams for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident teams.
 */
export const ListIncidentTeams = (props: ListIncidentTeamsProps) => (
  <Get<IncidentTeamsResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentTeamsQueryParams, void>
    path={`/api/v2/teams`}
    
    {...props}
  />
);

export type UseListIncidentTeamsProps = Omit<UseGetProps<IncidentTeamsResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentTeamsQueryParams, void>, "path">;

/**
 * Get a list of all incident teams
 * 
 * Get all incident teams for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident teams.
 */
export const useListIncidentTeams = (props: UseListIncidentTeamsProps) => useGet<IncidentTeamsResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, ListIncidentTeamsQueryParams, void>(`/api/v2/teams`, props);

/**
 * Get a list of all incident teams
 * 
 * Get all incident teams for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident teams.
 */
export const listIncidentTeamsPromise = (props: ListIncidentTeamsQueryParams) => HttpGET<IncidentTeamsResponse, ListIncidentTeamsQueryParams>('/api/v2/teams', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateIncidentTeamProps = Omit<MutateProps<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentTeamCreateRequest, void>, "path" | "verb">;

/**
 * Create a new incident team
 * 
 * Creates a new incident team.
 */
export const CreateIncidentTeam = (props: CreateIncidentTeamProps) => (
  <Mutate<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentTeamCreateRequest, void>
    verb="POST"
    path={`/api/v2/teams`}
    
    {...props}
  />
);

export type UseCreateIncidentTeamProps = Omit<UseMutateProps<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentTeamCreateRequest, void>, "path" | "verb">;

/**
 * Create a new incident team
 * 
 * Creates a new incident team.
 */
export const useCreateIncidentTeam = (props: UseCreateIncidentTeamProps) => useMutate<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentTeamCreateRequest, void>("POST", `/api/v2/teams`, props);

export type CreateIncidentTeamPromiseProps = Omit<IncidentTeamCreateRequest, "_authentication_token">;
/**
 * Create a new incident team
 * 
 * Creates a new incident team.
 */
export const createIncidentTeamPromise = (props: CreateIncidentTeamPromiseProps) => HttpPOST<IncidentTeamResponse, CreateIncidentTeamPromiseProps>('/api/v2/teams')(props);


export type DeleteIncidentTeamProps = Omit<MutateProps<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an existing incident team
 * 
 * Deletes an existing incident team.
 */
export const DeleteIncidentTeam = (props: DeleteIncidentTeamProps) => (
  <Mutate<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/teams`}
    
    {...props}
  />
);

export type UseDeleteIncidentTeamProps = Omit<UseMutateProps<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>, "path" | "verb">;

/**
 * Delete an existing incident team
 * 
 * Deletes an existing incident team.
 */
export const useDeleteIncidentTeam = (props: UseDeleteIncidentTeamProps) => useMutate<void, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, string, void>("DELETE", `/api/v2/teams`, {   ...props });


export interface GetIncidentTeamQueryParams {
  /**
   * Specifies which types of related objects should be included in the response.
   */
  include?: IncidentRelatedObject;
}

export interface GetIncidentTeamPathParams {
  /**
   * The ID of the incident team.
   */
  team_id: string
}

export type GetIncidentTeamProps = Omit<GetProps<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentTeamQueryParams, GetIncidentTeamPathParams>, "path"> & GetIncidentTeamPathParams;

/**
 * Get details of an incident team
 * 
 * Get details of an incident team. If the `include[users]` query parameter is provided,
 * the included attribute will contain the users related to these incident teams.
 */
export const GetIncidentTeam = ({team_id, ...props}: GetIncidentTeamProps) => (
  <Get<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentTeamQueryParams, GetIncidentTeamPathParams>
    path={`/api/v2/teams/${team_id}`}
    
    {...props}
  />
);

export type UseGetIncidentTeamProps = Omit<UseGetProps<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentTeamQueryParams, GetIncidentTeamPathParams>, "path"> & GetIncidentTeamPathParams;

/**
 * Get details of an incident team
 * 
 * Get details of an incident team. If the `include[users]` query parameter is provided,
 * the included attribute will contain the users related to these incident teams.
 */
export const useGetIncidentTeam = ({team_id, ...props}: UseGetIncidentTeamProps) => useGet<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, GetIncidentTeamQueryParams, GetIncidentTeamPathParams>((paramsInPath: GetIncidentTeamPathParams) => `/api/v2/teams/${paramsInPath.team_id}`, {  pathParams: { team_id }, ...props });

/**
 * Get details of an incident team
 * 
 * Get details of an incident team. If the `include[users]` query parameter is provided,
 * the included attribute will contain the users related to these incident teams.
 */
export const getIncidentTeamPromise = (props: GetIncidentTeamQueryParams) => HttpGET<IncidentTeamResponse, GetIncidentTeamQueryParams>('/api/v2/teams/${team_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateIncidentTeamPathParams {
  /**
   * The ID of the incident team.
   */
  team_id: string
}

export type UpdateIncidentTeamProps = Omit<MutateProps<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentTeamUpdateRequest, UpdateIncidentTeamPathParams>, "path" | "verb"> & UpdateIncidentTeamPathParams;

/**
 * Update an existing incident team
 * 
 * Updates an existing incident team. Only provide the attributes which should be updated as this request is a partial update.
 */
export const UpdateIncidentTeam = ({team_id, ...props}: UpdateIncidentTeamProps) => (
  <Mutate<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentTeamUpdateRequest, UpdateIncidentTeamPathParams>
    verb="PATCH"
    path={`/api/v2/teams/${team_id}`}
    
    {...props}
  />
);

export type UseUpdateIncidentTeamProps = Omit<UseMutateProps<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentTeamUpdateRequest, UpdateIncidentTeamPathParams>, "path" | "verb"> & UpdateIncidentTeamPathParams;

/**
 * Update an existing incident team
 * 
 * Updates an existing incident team. Only provide the attributes which should be updated as this request is a partial update.
 */
export const useUpdateIncidentTeam = ({team_id, ...props}: UseUpdateIncidentTeamProps) => useMutate<IncidentTeamResponse, BadRequestResponseResponse | UnauthorizedResponseResponse | ForbiddenResponseResponse | NotFoundResponseResponse, void, IncidentTeamUpdateRequest, UpdateIncidentTeamPathParams>("PATCH", (paramsInPath: UpdateIncidentTeamPathParams) => `/api/v2/teams/${paramsInPath.team_id}`, {  pathParams: { team_id }, ...props });


export type SendInvitationsProps = Omit<MutateProps<UserInvitationsResponse, APIErrorResponse, void, UserInvitationsRequest, void>, "path" | "verb">;

/**
 * Send invitation emails
 * 
 * Sends emails to one or more users inviting them to join the organization.
 */
export const SendInvitations = (props: SendInvitationsProps) => (
  <Mutate<UserInvitationsResponse, APIErrorResponse, void, UserInvitationsRequest, void>
    verb="POST"
    path={`/api/v2/user_invitations`}
    
    {...props}
  />
);

export type UseSendInvitationsProps = Omit<UseMutateProps<UserInvitationsResponse, APIErrorResponse, void, UserInvitationsRequest, void>, "path" | "verb">;

/**
 * Send invitation emails
 * 
 * Sends emails to one or more users inviting them to join the organization.
 */
export const useSendInvitations = (props: UseSendInvitationsProps) => useMutate<UserInvitationsResponse, APIErrorResponse, void, UserInvitationsRequest, void>("POST", `/api/v2/user_invitations`, props);

export type SendInvitationsPromiseProps = Omit<UserInvitationsRequest, "_authentication_token">;
/**
 * Send invitation emails
 * 
 * Sends emails to one or more users inviting them to join the organization.
 */
export const sendInvitationsPromise = (props: SendInvitationsPromiseProps) => HttpPOST<UserInvitationsResponse, SendInvitationsPromiseProps>('/api/v2/user_invitations')(props);


export interface GetInvitationPathParams {
  /**
   * The UUID of the user invitation.
   */
  user_invitation_uuid: string
}

export type GetInvitationProps = Omit<GetProps<UserInvitationResponse, APIErrorResponse, void, GetInvitationPathParams>, "path"> & GetInvitationPathParams;

/**
 * Get a user invitation
 * 
 * Returns a single user invitation by its UUID.
 */
export const GetInvitation = ({user_invitation_uuid, ...props}: GetInvitationProps) => (
  <Get<UserInvitationResponse, APIErrorResponse, void, GetInvitationPathParams>
    path={`/api/v2/user_invitations/${user_invitation_uuid}`}
    
    {...props}
  />
);

export type UseGetInvitationProps = Omit<UseGetProps<UserInvitationResponse, APIErrorResponse, void, GetInvitationPathParams>, "path"> & GetInvitationPathParams;

/**
 * Get a user invitation
 * 
 * Returns a single user invitation by its UUID.
 */
export const useGetInvitation = ({user_invitation_uuid, ...props}: UseGetInvitationProps) => useGet<UserInvitationResponse, APIErrorResponse, void, GetInvitationPathParams>((paramsInPath: GetInvitationPathParams) => `/api/v2/user_invitations/${paramsInPath.user_invitation_uuid}`, {  pathParams: { user_invitation_uuid }, ...props });

/**
 * Get a user invitation
 * 
 * Returns a single user invitation by its UUID.
 */
export const getInvitationPromise = (props: void) => HttpGET<UserInvitationResponse, void>('/api/v2/user_invitations/${user_invitation_uuid}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface ListUsersQueryParams {
  /**
   * Size for a given page.
   */
  "page[size]"?: number;
  /**
   * Specific page number to return.
   */
  "page[number]"?: number;
  /**
   * User attribute to order results by. Sort order is ascending by default.
   * Sort order is descending if the field
   * is prefixed by a negative sign, for example `sort=-name`. Options: `name`,
   * `modified_at`, `user_count`.
   */
  sort?: string;
  /**
   * Direction of sort. Options: `asc`, `desc`.
   */
  sort_dir?: QuerySortOrder;
  /**
   * Filter all users by the given string. Defaults to no filtering.
   */
  filter?: string;
  /**
   * Filter on status attribute.
   * Comma separated list, with possible values `Active`, `Pending`, and `Disabled`.
   * Defaults to no filtering.
   */
  "filter[status]"?: string;
}

export type ListUsersProps = Omit<GetProps<UsersResponse, APIErrorResponse, ListUsersQueryParams, void>, "path">;

/**
 * List all users
 * 
 * Get the list of all users in the organization. This list includes
 * all users even if they are deactivated or unverified.
 */
export const ListUsers = (props: ListUsersProps) => (
  <Get<UsersResponse, APIErrorResponse, ListUsersQueryParams, void>
    path={`/api/v2/users`}
    
    {...props}
  />
);

export type UseListUsersProps = Omit<UseGetProps<UsersResponse, APIErrorResponse, ListUsersQueryParams, void>, "path">;

/**
 * List all users
 * 
 * Get the list of all users in the organization. This list includes
 * all users even if they are deactivated or unverified.
 */
export const useListUsers = (props: UseListUsersProps) => useGet<UsersResponse, APIErrorResponse, ListUsersQueryParams, void>(`/api/v2/users`, props);

/**
 * List all users
 * 
 * Get the list of all users in the organization. This list includes
 * all users even if they are deactivated or unverified.
 */
export const listUsersPromise = (props: ListUsersQueryParams) => HttpGET<UsersResponse, ListUsersQueryParams>('/api/v2/users', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export type CreateUserProps = Omit<MutateProps<UserResponse, APIErrorResponse, void, UserCreateRequest, void>, "path" | "verb">;

/**
 * Create a user
 * 
 * Create a user for your organization.
 */
export const CreateUser = (props: CreateUserProps) => (
  <Mutate<UserResponse, APIErrorResponse, void, UserCreateRequest, void>
    verb="POST"
    path={`/api/v2/users`}
    
    {...props}
  />
);

export type UseCreateUserProps = Omit<UseMutateProps<UserResponse, APIErrorResponse, void, UserCreateRequest, void>, "path" | "verb">;

/**
 * Create a user
 * 
 * Create a user for your organization.
 */
export const useCreateUser = (props: UseCreateUserProps) => useMutate<UserResponse, APIErrorResponse, void, UserCreateRequest, void>("POST", `/api/v2/users`, props);

export type CreateUserPromiseProps = Omit<UserCreateRequest, "_authentication_token">;
/**
 * Create a user
 * 
 * Create a user for your organization.
 */
export const createUserPromise = (props: CreateUserPromiseProps) => HttpPOST<UserResponse, CreateUserPromiseProps>('/api/v2/users')(props);


export type DisableUserProps = Omit<MutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Disable a user
 * 
 * Disable a user. Can only be used with an application key belonging
 * to an administrator user.
 */
export const DisableUser = (props: DisableUserProps) => (
  <Mutate<void, APIErrorResponse, void, string, void>
    verb="DELETE"
    path={`/api/v2/users`}
    
    {...props}
  />
);

export type UseDisableUserProps = Omit<UseMutateProps<void, APIErrorResponse, void, string, void>, "path" | "verb">;

/**
 * Disable a user
 * 
 * Disable a user. Can only be used with an application key belonging
 * to an administrator user.
 */
export const useDisableUser = (props: UseDisableUserProps) => useMutate<void, APIErrorResponse, void, string, void>("DELETE", `/api/v2/users`, {   ...props });


export interface GetUserPathParams {
  /**
   * The ID of the user.
   */
  user_id: string
}

export type GetUserProps = Omit<GetProps<UserResponse, APIErrorResponse, void, GetUserPathParams>, "path"> & GetUserPathParams;

/**
 * Get user details
 * 
 * Get a user in the organization specified by the users `user_id`.
 */
export const GetUser = ({user_id, ...props}: GetUserProps) => (
  <Get<UserResponse, APIErrorResponse, void, GetUserPathParams>
    path={`/api/v2/users/${user_id}`}
    
    {...props}
  />
);

export type UseGetUserProps = Omit<UseGetProps<UserResponse, APIErrorResponse, void, GetUserPathParams>, "path"> & GetUserPathParams;

/**
 * Get user details
 * 
 * Get a user in the organization specified by the users `user_id`.
 */
export const useGetUser = ({user_id, ...props}: UseGetUserProps) => useGet<UserResponse, APIErrorResponse, void, GetUserPathParams>((paramsInPath: GetUserPathParams) => `/api/v2/users/${paramsInPath.user_id}`, {  pathParams: { user_id }, ...props });

/**
 * Get user details
 * 
 * Get a user in the organization specified by the users `user_id`.
 */
export const getUserPromise = (props: void) => HttpGET<UserResponse, void>('/api/v2/users/${user_id}', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface UpdateUserPathParams {
  /**
   * The ID of the user.
   */
  user_id: string
}

export type UpdateUserProps = Omit<MutateProps<UserResponse, APIErrorResponse, void, UserUpdateRequest, UpdateUserPathParams>, "path" | "verb"> & UpdateUserPathParams;

/**
 * Update a user
 * 
 * Edit a user. Can only be used with an application key belonging
 * to an administrator user.
 */
export const UpdateUser = ({user_id, ...props}: UpdateUserProps) => (
  <Mutate<UserResponse, APIErrorResponse, void, UserUpdateRequest, UpdateUserPathParams>
    verb="PATCH"
    path={`/api/v2/users/${user_id}`}
    
    {...props}
  />
);

export type UseUpdateUserProps = Omit<UseMutateProps<UserResponse, APIErrorResponse, void, UserUpdateRequest, UpdateUserPathParams>, "path" | "verb"> & UpdateUserPathParams;

/**
 * Update a user
 * 
 * Edit a user. Can only be used with an application key belonging
 * to an administrator user.
 */
export const useUpdateUser = ({user_id, ...props}: UseUpdateUserProps) => useMutate<UserResponse, APIErrorResponse, void, UserUpdateRequest, UpdateUserPathParams>("PATCH", (paramsInPath: UpdateUserPathParams) => `/api/v2/users/${paramsInPath.user_id}`, {  pathParams: { user_id }, ...props });


export interface ListUserOrganizationsPathParams {
  /**
   * The ID of the user.
   */
  user_id: string
}

export type ListUserOrganizationsProps = Omit<GetProps<UserResponse, APIErrorResponse, void, ListUserOrganizationsPathParams>, "path"> & ListUserOrganizationsPathParams;

/**
 * Get a user organization
 * 
 * Get a user organization. Returns the user information and all organizations
 * joined by this user.
 */
export const ListUserOrganizations = ({user_id, ...props}: ListUserOrganizationsProps) => (
  <Get<UserResponse, APIErrorResponse, void, ListUserOrganizationsPathParams>
    path={`/api/v2/users/${user_id}/orgs`}
    
    {...props}
  />
);

export type UseListUserOrganizationsProps = Omit<UseGetProps<UserResponse, APIErrorResponse, void, ListUserOrganizationsPathParams>, "path"> & ListUserOrganizationsPathParams;

/**
 * Get a user organization
 * 
 * Get a user organization. Returns the user information and all organizations
 * joined by this user.
 */
export const useListUserOrganizations = ({user_id, ...props}: UseListUserOrganizationsProps) => useGet<UserResponse, APIErrorResponse, void, ListUserOrganizationsPathParams>((paramsInPath: ListUserOrganizationsPathParams) => `/api/v2/users/${paramsInPath.user_id}/orgs`, {  pathParams: { user_id }, ...props });

/**
 * Get a user organization
 * 
 * Get a user organization. Returns the user information and all organizations
 * joined by this user.
 */
export const listUserOrganizationsPromise = (props: void) => HttpGET<UserResponse, void>('/api/v2/users/${user_id}/orgs', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);


export interface ListUserPermissionsPathParams {
  /**
   * The ID of the user.
   */
  user_id: string
}

export type ListUserPermissionsProps = Omit<GetProps<PermissionsResponse, APIErrorResponse, void, ListUserPermissionsPathParams>, "path"> & ListUserPermissionsPathParams;

/**
 * Get a user permissions
 * 
 * Get a user permission set. Returns a list of the users permissions
 * granted by the associated user's roles.
 */
export const ListUserPermissions = ({user_id, ...props}: ListUserPermissionsProps) => (
  <Get<PermissionsResponse, APIErrorResponse, void, ListUserPermissionsPathParams>
    path={`/api/v2/users/${user_id}/permissions`}
    
    {...props}
  />
);

export type UseListUserPermissionsProps = Omit<UseGetProps<PermissionsResponse, APIErrorResponse, void, ListUserPermissionsPathParams>, "path"> & ListUserPermissionsPathParams;

/**
 * Get a user permissions
 * 
 * Get a user permission set. Returns a list of the users permissions
 * granted by the associated user's roles.
 */
export const useListUserPermissions = ({user_id, ...props}: UseListUserPermissionsProps) => useGet<PermissionsResponse, APIErrorResponse, void, ListUserPermissionsPathParams>((paramsInPath: ListUserPermissionsPathParams) => `/api/v2/users/${paramsInPath.user_id}/permissions`, {  pathParams: { user_id }, ...props });

/**
 * Get a user permissions
 * 
 * Get a user permission set. Returns a list of the users permissions
 * granted by the associated user's roles.
 */
export const listUserPermissionsPromise = (props: void) => HttpGET<PermissionsResponse, void>('/api/v2/users/${user_id}/permissions', { qsStringifyOptions: { arrayFormat: 'brackets' } })(props);

